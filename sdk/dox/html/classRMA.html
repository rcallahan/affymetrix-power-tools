<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Affymetrix Power Tools: RMA Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>RMA Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="RMA" -->
<p>Holds methods for computing the popular Robust Muliarray <a class="el" href="classAverage.html">Average</a> of Microarrays (<a class="el" href="classRMA.html" title="Holds methods for computing the popular Robust Muliarray Average of Microarrays (RMA).">RMA</a>).  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="RMA_8h_source.html">RMA.h</a>&gt;</code></p>

<p><a href="classRMA-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMA.html#a978989f98fa6719135cb9a020ded94c9">medianPolishPSet</a> (const std::vector&lt; int &gt; &amp;indexes, std::vector&lt; float &gt; &amp;results)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use median polish to get a summary of probe set concentrations using probes that are at the row positions in PM specified by indexes.  <a href="#a978989f98fa6719135cb9a020ded94c9"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMA.html#ac711699260fac62869e75aa3155c2f1a">medianPolishPsetFromMatrix</a> (std::vector&lt; std::vector&lt; float &gt; &gt; &amp;pmMatrix, int numRow, int numCol, std::vector&lt; float &gt; &amp;colEstimates, std::vector&lt; float &gt; &amp;rowEstimates, bool doLog=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Static version of medianPolishSet for when it isn't convenient to have an <a class="el" href="classRMA.html" title="Holds methods for computing the popular Robust Muliarray Average of Microarrays (RMA).">RMA</a> instance.  <a href="#ac711699260fac62869e75aa3155c2f1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMA.html#a45f4c1b837663171147f237c2f24296f">medianPolish</a> (std::vector&lt; std::vector&lt; float &gt; &gt; &amp;pmMatrix, int numRow, int numCol, std::vector&lt; float &gt; &amp;colEstimates, std::vector&lt; float &gt; &amp;rowEstimates)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Static version of medianPolishSet for when it isn't convenient to have an <a class="el" href="classRMA.html" title="Holds methods for computing the popular Robust Muliarray Average of Microarrays (RMA).">RMA</a> instance.  <a href="#a45f4c1b837663171147f237c2f24296f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMA.html#a7f5bef27ec32e7e24c12c9cfd15299d1">medianPolishWithPrecomputedEffectsOnePass</a> (std::vector&lt; std::vector&lt; float &gt; &gt; &amp;pmMatrix, int numChips, int numProbes, std::vector&lt; float &gt; &amp;colEstimates, std::vector&lt; float &gt; &amp;rowEstimates, bool doLog=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Static version of medianPolishWithPrecomputedEffectsOnePass This version will use precomputed feature effects as input values and perform the usual median polish algorithm until convergence.  <a href="#a7f5bef27ec32e7e24c12c9cfd15299d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMA.html#ab03b10f51a1f3cbf4e0564d46c13238b">medianPolishWithPrecomputedEffectsUsedAsSeedValues</a> (std::vector&lt; std::vector&lt; float &gt; &gt; &amp;pmMatrix, int numChips, int numProbes, std::vector&lt; float &gt; &amp;colEstimates, std::vector&lt; float &gt; &amp;rowEstimates, bool doLog=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Static version of medianPolishWithPrecomputedEffectsUsedAsSeedValues This version will use precomputed feature effects as input values and perform the usual median polish algorithm until convergence.  <a href="#ab03b10f51a1f3cbf4e0564d46c13238b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMA.html#ac30f9a0a0257c5bb05b0ec498a3987ce">vectorMin</a> (std::vector&lt; float &gt; &amp;dat)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the minimum value in a vector.  <a href="#ac30f9a0a0257c5bb05b0ec498a3987ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMA.html#ac3b15107b4f1280fa8590950d2be2c4a">vectorMax</a> (std::vector&lt; float &gt; &amp;dat)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the maximum value in a vector.  <a href="#ac3b15107b4f1280fa8590950d2be2c4a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMA.html#afbe09798d6421471fa47cbd6bfe72768">vectorMean</a> (std::vector&lt; float &gt; &amp;dat)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the mean of a given vector.  <a href="#afbe09798d6421471fa47cbd6bfe72768"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMA.html#a0cbda20b31e8bdf7ee016787467cdb97">vectorVariance</a> (std::vector&lt; float &gt; &amp;dat)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the variance of a given column.  <a href="#a0cbda20b31e8bdf7ee016787467cdb97"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMA.html#a9dfdce9f02290fa2cf1e7902f29fc114">vectorQuantile</a> (std::vector&lt; float &gt; &amp;dat, double quantile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the value at a particular quantile, Example quantile would be .5 which is equivalent to the median.  <a href="#a9dfdce9f02290fa2cf1e7902f29fc114"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMA.html#a7ebecfa33f4983b4c8c5e6bc83eee11e">vectorIqr</a> (std::vector&lt; float &gt; &amp;dat)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the range of values from .75 quantile to .25 quantile.  <a href="#a7ebecfa33f4983b4c8c5e6bc83eee11e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMA.html#a6ca4697cbf7e4e48fa7a3ee3e2e7f115">findBandWidth</a> (std::vector&lt; float &gt; &amp;dat)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the bw.nrd0() function in R to decide kernel bandwidth.  <a href="#a6ca4697cbf7e4e48fa7a3ee3e2e7f115"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMA.html#a5e0f853a04ac15793a53aa666f9d547f">colMassDist</a> (std::vector&lt; float &gt; &amp;dat, double bandWidth, double from, double to, std::vector&lt; float &gt; &amp;yVec, int numBins)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Spread the mass around our histogram bins.  <a href="#a5e0f853a04ac15793a53aa666f9d547f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMA.html#aa2c261bf85e0624d561c057668b06695">columnToVector</a> (double **PM, int numRows, int colIx, std::vector&lt; float &gt; &amp;toFill)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill in a vector from a given column of data.  <a href="#aa2c261bf85e0624d561c057668b06695"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMA.html#a113b790b81c3f863e6b2ab1350ebae4f">linearInterpolate</a> (double d, std::vector&lt; float &gt; &amp;x, std::vector&lt; float &gt; &amp;y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the interpolation for value d between x and y.  <a href="#a113b790b81c3f863e6b2ab1350ebae4f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMA.html#aee708b4478e5fa43ba6258651ac368b9">linearApprox</a> (std::vector&lt; float &gt; &amp;x, std::vector&lt; float &gt; &amp;y, std::vector&lt; float &gt; &amp;xOut, std::vector&lt; float &gt; &amp;yOut)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Linearly interpolate x and y using values in x out.  <a href="#aee708b4478e5fa43ba6258651ac368b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMA.html#af4e7490905030f1fa1f380320c91693e">modeOfData</a> (std::vector&lt; float &gt; &amp;dat, int numBins)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Here we are recreating the density() function in R with an Epanechnikov kernel.  <a href="#af4e7490905030f1fa1f380320c91693e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ec064a2094157f8498f57161851ee70"></a><!-- doxytag: member="RMA::printArray" ref="a0ec064a2094157f8498f57161851ee70" args="(float *dat, int size, float thresh=0)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>printArray</b> (float *dat, int size, float thresh=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3e208eaa82b60bcdf46284b5beccd1a"></a><!-- doxytag: member="RMA::printArray" ref="ac3e208eaa82b60bcdf46284b5beccd1a" args="(double *dat, int size, double thresh=0)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>printArray</b> (double *dat, int size, double thresh=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4879159d7da5036b806110b32c446f88"></a><!-- doxytag: member="RMA::arrayMax" ref="a4879159d7da5036b806110b32c446f88" args="(double *d, int count)" -->
static double&nbsp;</td><td class="memItemRight" valign="bottom"><b>arrayMax</b> (double *d, int count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8e62f1eaf2a0c6f3121a6a7de5e4644"></a><!-- doxytag: member="RMA::printVector" ref="af8e62f1eaf2a0c6f3121a6a7de5e4644" args="(std::vector&lt; float &gt; &amp;dat)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>printVector</b> (std::vector&lt; float &gt; &amp;dat)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMA.html#a147abbdd7daffd1ca36be245b6071cd3">fft</a> (std::vector&lt; float &gt; &amp;dat, bool inverse)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Do a fast fourier transform on data.  <a href="#a147abbdd7daffd1ca36be245b6071cd3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMA.html#a942b14d13a92642bec3c7910804675c0">convolveDataKernel</a> (std::vector&lt; float &gt; &amp;yVec, std::vector&lt; float &gt; &amp;kernelWords, int count)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convolves the real numbers in two vectors.  <a href="#a942b14d13a92642bec3c7910804675c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMA.html#af979f3581dfc7f2a479db2bb221ec3e1">estimateBgParam</a> (std::vector&lt; float &gt; &amp;data, double *mu, double *sigma, double *alpha, int numBins=16384)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the parameters necesary to do the <a class="el" href="classRMA.html" title="Holds methods for computing the popular Robust Muliarray Average of Microarrays (RMA).">RMA</a> background subtraction.  <a href="#af979f3581dfc7f2a479db2bb221ec3e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMA.html#a1cefcd540e7163dec064c33c50dff2b8">bgSubData</a> (float value, double mu, double sigma, double alpha, bool &amp;error)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The "true" signal is then estimated as:  <a href="#a1cefcd540e7163dec064c33c50dff2b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMA.html#aaac83c718307d16f9a445d79de681abe">backgroundCorrect</a> (std::vector&lt; float &gt; &amp;data, int numBins=16384)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classRMA.html" title="Holds methods for computing the popular Robust Muliarray Average of Microarrays (RMA).">RMA</a> background correct subtraction.  <a href="#aaac83c718307d16f9a445d79de681abe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMA.html#ad8ba6f24a1b32e431541c4d17bb02670">getRowEffect</a> (std::vector&lt; std::vector&lt; float &gt; &gt; &amp;psMatrix, int numRow, int numCol, std::vector&lt; float &gt; &amp;rowEffect)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the median for the rows.  <a href="#ad8ba6f24a1b32e431541c4d17bb02670"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMA.html#af3857969e5a7b87ed1592221d43b4820">subRowEffect</a> (std::vector&lt; std::vector&lt; float &gt; &gt; &amp;psMatrix, int numRow, int numCol, std::vector&lt; float &gt; &amp;rowEffect)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subtract the median off of each row.  <a href="#af3857969e5a7b87ed1592221d43b4820"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMA.html#ad0b693b6847cee2a00733e0e060143f1">getColEffect</a> (std::vector&lt; std::vector&lt; float &gt; &gt; &amp;psMatrix, int numRow, int numCol, std::vector&lt; float &gt; &amp;colEffect)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the median for the columns.  <a href="#ad0b693b6847cee2a00733e0e060143f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMA.html#a765dc04890b9a824bac0b8efa057558c">subColEffect</a> (std::vector&lt; std::vector&lt; float &gt; &gt; &amp;psMatrix, int numRow, int numCol, std::vector&lt; float &gt; &amp;colEffect)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subtract the median off of each column.  <a href="#a765dc04890b9a824bac0b8efa057558c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMA.html#af2944caac48a0ca2eccd1082f54268aa">matrixSum</a> (std::vector&lt; std::vector&lt; float &gt; &gt; &amp;psMatrix, int numRow, int numCol)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the sum of a matrix.  <a href="#af2944caac48a0ca2eccd1082f54268aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMA.html#a81cabb33227ea30643a91132be491e13">phi</a> (double x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Standard normal probability density function.  <a href="#a81cabb33227ea30643a91132be491e13"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMA.html#aa9169b59f0b3d2677c17a273d4788f44">PHI</a> (double x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The cdf function for standard normal distribution consistant with Bolstad's <a class="el" href="classRMA.html" title="Holds methods for computing the popular Robust Muliarray Average of Microarrays (RMA).">RMA</a> notatation.  <a href="#aa9169b59f0b3d2677c17a273d4788f44"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMA.html#a8ea065c5a07bad418069eff2e5336f99">pnorm</a> (double z)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cumulative standard normal density function.  <a href="#a8ea065c5a07bad418069eff2e5336f99"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMA.html#a50ad140c16af79df52b4001d59457080">getRanks</a> (struct <a class="el" href="struct__rmaPair.html">_rmaPair</a> *pairs, int count, std::vector&lt; int &gt; &amp;ranks)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the ranks of <a class="el" href="struct__rmaPair.html" title="Utility structure for sorting by data, but remembering rank.">_rmaPair</a> structures using the same algorthim as R to break ties.  <a href="#a50ad140c16af79df52b4001d59457080"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRMA.html#ae035731f10d7df8b91c248685a714315">quantileNorm</a> (std::vector&lt; std::vector&lt; float &gt; &gt; &amp;data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Quantile Norm data using same algorithm to break ties as <a class="el" href="classRMA.html" title="Holds methods for computing the popular Robust Muliarray Average of Microarrays (RMA).">RMA</a> This function is deprecated as normalization sdk module now supports bioconductor style quantile normalization.  <a href="#ae035731f10d7df8b91c248685a714315"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Holds methods for computing the popular Robust Muliarray <a class="el" href="classAverage.html">Average</a> of Microarrays (<a class="el" href="classRMA.html" title="Holds methods for computing the popular Robust Muliarray Average of Microarrays (RMA).">RMA</a>). </p>
<p>Implements the method described in "Exploration, normalization, and summaries of high density oligonucleotide array probe level data", Irizarry RA, Hobbs B, Collin F, Beazer-Barclay YD, Antonellis KJ, Scherf U, Speed TP., Biostatistics. 2003 Apr;4(2):249-64. Core routines are two static functions for manipulating matrices. This class is mainly a collection of static methods to manipulate vectors and matrices to perform an <a class="el" href="classRMA.html" title="Holds methods for computing the popular Robust Muliarray Average of Microarrays (RMA).">RMA</a> analysis. <a class="el" href="classRMA.html" title="Holds methods for computing the popular Robust Muliarray Average of Microarrays (RMA).">RMA</a> really consists of three separate steps:</p>
<p>1) Background estimation which occurs at the chip level as implemented by <a class="el" href="classRMA.html#aaac83c718307d16f9a445d79de681abe" title="RMA background correct subtraction.">backgroundCorrect()</a>. The background subtraction is more complicated than a simple subtraction and accounts for a substantial amount of the code.</p>
<p>2) Quantile normalization. As the original normalization module of the affy sdk used a different manner of resolving ties than the bioconductor version there are methods to normalize a matrix of chip data implemented in <a class="el" href="classRMA.html#ae035731f10d7df8b91c248685a714315" title="Quantile Norm data using same algorithm to break ties as RMA This function is deprecated as normaliza...">quantileNorm()</a>. The normalization module has since been extended to reproduce the bioconductor results and the code here will be deprecated soon.</p>
<p>3) Probeset summary. Use the median polish algorithm to estimate the target response and feature response using <a class="el" href="classRMA.html#ac711699260fac62869e75aa3155c2f1a" title="Static version of medianPolishSet for when it isn&#39;t convenient to have an RMA instance...">medianPolishPsetFromMatrix()</a>. Target response is used as the signal level estimates. While this is where the real "work" of doing probeset level estimates occurs, it takes up very little code as the median polish algorithm is simple to implement. </p>

<p>Definition at line <a class="el" href="RMA_8h_source.html#l00068">68</a> of file <a class="el" href="RMA_8h_source.html">RMA.h</a>.</p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aaac83c718307d16f9a445d79de681abe"></a><!-- doxytag: member="RMA::backgroundCorrect" ref="aaac83c718307d16f9a445d79de681abe" args="(std::vector&lt; float &gt; &amp;data, int numBins=16384)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RMA::backgroundCorrect </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBins</em> = <code>16384</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classRMA.html" title="Holds methods for computing the popular Robust Muliarray Average of Microarrays (RMA).">RMA</a> background correct subtraction. </p>
<p>The <a class="el" href="classRMA.html" title="Holds methods for computing the popular Robust Muliarray Average of Microarrays (RMA).">RMA</a> bacground subtraction is a little complicated. The details are available in Ben Bolstad's thesis dissertation: <a href="http://stat-www.berkeley.edu/users/bolstad/Dissertation/Bolstad_2004_Dissertation.pdf">http://stat-www.berkeley.edu/users/bolstad/Dissertation/Bolstad_2004_Dissertation.pdf</a> The basic idea is that the signal is exponential and the background is additive gaussian. There are a lot of fun integrals to show that the joint distribution can be found to estimate the true signal given the observed signal on the chip and the parameters mu and sigma for the background and alpha for the exponential. Estimating mu, sigma and alpha explicitly is difficult though so <a class="el" href="classRMA.html" title="Holds methods for computing the popular Robust Muliarray Average of Microarrays (RMA).">RMA</a> uses an ad-hoc method where mu is estimated as the mode of the data, sigma is estimated by the variation in the lower 50% quantile tail and alpha is estimated as an exponential fit to the upper 50% quantile tail. The "true" signal is then estimated as:</p>
<p>X = a + b(phi(a/b)/PHI(a/b)) where a = signal - mu - (sigma^2 * alpha) b = sigma</p>
<p>phi and PHI are standard normal density function and distribution function respectively given as:</p>
<p>phi(z) = 1 / sqrt(2*pi) * exp(-.5*z^2) PHI(z) = -inf^z 1 / sqrt(2*pi) exp(-.5w^2) dw</p>
<p>Note that this all happens on a per chip basis. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>- vector of data for a chip. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numBins</em>&nbsp;</td><td>- number of bins to use for estimating mode of data for background parameters. Must be a power of 2. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="RMA_8cpp_source.html#l01065">1065</a> of file <a class="el" href="RMA_8cpp_source.html">RMA.cpp</a>.</p>

<p>References <a class="el" href="RMA_8h_source.html#l00341">bgSubData()</a>, <a class="el" href="Err_8cpp_source.html#l00068">Err::errAbort()</a>, and <a class="el" href="RMA_8cpp_source.html#l00909">estimateBgParam()</a>.</p>

</div>
</div>
<a class="anchor" id="a1cefcd540e7163dec064c33c50dff2b8"></a><!-- doxytag: member="RMA::bgSubData" ref="a1cefcd540e7163dec064c33c50dff2b8" args="(float value, double mu, double sigma, double alpha, bool &amp;error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static float RMA::bgSubData </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The "true" signal is then estimated as: </p>
<p>X = a + b(phi(a/b)/PHI(a/b)) where a = signal - mu - (sigma^2 * alpha) b = sigma</p>
<p>phi and PHI are standard normal density function and distribution function respectively given as:</p>
<p>phi(z) = 1 / sqrt(2*pi) * exp(-.5*z^2) PHI(z) = -inf^z 1 / sqrt(2*pi) exp(-.5w^2) dw </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>original value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mu</em>&nbsp;</td><td>- mode of "background" signal. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sigma</em>&nbsp;</td><td>- stdev of "background" signal </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha</em>&nbsp;</td><td>- mean of exponential "true" signal </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bg adjusted value. </dd></dl>

<p>Definition at line <a class="el" href="RMA_8h_source.html#l00341">341</a> of file <a class="el" href="RMA_8h_source.html">RMA.h</a>.</p>

<p>References <a class="el" href="RMA_8cpp_source.html#l00968">phi()</a>, and <a class="el" href="RMA_8cpp_source.html#l00978">pnorm()</a>.</p>

<p>Referenced by <a class="el" href="RMA_8cpp_source.html#l01065">backgroundCorrect()</a>, and <a class="el" href="RmaBgTran_8cpp_source.html#l00098">RmaBgTran::transform()</a>.</p>

</div>
</div>
<a class="anchor" id="a5e0f853a04ac15793a53aa666f9d547f"></a><!-- doxytag: member="RMA::colMassDist" ref="a5e0f853a04ac15793a53aa666f9d547f" args="(std::vector&lt; float &gt; &amp;dat, double bandWidth, double from, double to, std::vector&lt; float &gt; &amp;yVec, int numBins)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RMA::colMassDist </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>bandWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>yVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBins</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Spread the mass around our histogram bins. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dat</em>&nbsp;</td><td>- data of interest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bandWidth</em>&nbsp;</td><td>- Bandwidth of mass distribution. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>from</em>&nbsp;</td><td>- begininning of dist. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>to</em>&nbsp;</td><td>- end of values. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>yVec</em>&nbsp;</td><td>- vector of bins to spread mass into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numBins</em>&nbsp;</td><td>- number of bins in yVec.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dat</em>&nbsp;</td><td>- data of interest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bandWidth</em>&nbsp;</td><td>- Bandwidth of mass distribution. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>yVec</em>&nbsp;</td><td>- vector of bins to spread mass into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numBins</em>&nbsp;</td><td>- number of bins in yVec. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="RMA_8cpp_source.html#l00608">608</a> of file <a class="el" href="RMA_8cpp_source.html">RMA.cpp</a>.</p>

<p>References <a class="el" href="RMA_8cpp_source.html#l00559">vectorMax()</a>, and <a class="el" href="RMA_8cpp_source.html#l00541">vectorMin()</a>.</p>

<p>Referenced by <a class="el" href="RMA_8cpp_source.html#l00827">modeOfData()</a>.</p>

</div>
</div>
<a class="anchor" id="aa2c261bf85e0624d561c057668b06695"></a><!-- doxytag: member="RMA::columnToVector" ref="aa2c261bf85e0624d561c057668b06695" args="(double **PM, int numRows, int colIx, std::vector&lt; float &gt; &amp;toFill)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RMA::columnToVector </td>
          <td>(</td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>PM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>colIx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>toFill</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fill in a vector from a given column of data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>PM</em>&nbsp;</td><td>- Matrix to fill in from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numRows</em>&nbsp;</td><td>- Number of rows in matrix, will be vector length. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colIx</em>&nbsp;</td><td>- Column number to create vector from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>toFill</em>&nbsp;</td><td>- Vector to fill in with column data. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="RMA_8cpp_source.html#l00805">805</a> of file <a class="el" href="RMA_8cpp_source.html">RMA.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a942b14d13a92642bec3c7910804675c0"></a><!-- doxytag: member="RMA::convolveDataKernel" ref="a942b14d13a92642bec3c7910804675c0" args="(std::vector&lt; float &gt; &amp;yVec, std::vector&lt; float &gt; &amp;kernelWords, int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RMA::convolveDataKernel </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>yVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>kernelWords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convolves the real numbers in two vectors. </p>
<p>Fill in kerelwords with the convolved data.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>yVec</em>&nbsp;</td><td>- binned up data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kernelWords</em>&nbsp;</td><td>- kernel function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>- Number of entries in yVec and kernelWords.</td></tr>
  </table>
  </dd>
</dl>
<p>Fill in kerelwords with the convolved data. Note that yVec and kernel words must be a size which is a power of two (i.e. 256, 512, 1024, etc. )</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>yVec</em>&nbsp;</td><td>- binned up data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>kernelWords</em>&nbsp;</td><td>- kernel function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>- Number of entries in yVec and kernelWords. </td></tr>
  </table>
  </dd>
</dl>

<p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000282">Todo:</a></b></dt><dd>This check looks ok, but on some hardware very small deviations make the floor and ceil fail /// assert(floor(log((double)yVec.size()) / log(2.0)) == ceil(log((double)yVec.size()) / log(2.0))); </dd></dl>
</p>

<p>Definition at line <a class="el" href="RMA_8cpp_source.html#l00658">658</a> of file <a class="el" href="RMA_8cpp_source.html">RMA.cpp</a>.</p>

<p>References <a class="el" href="RMA_8cpp_source.html#l01095">fft()</a>.</p>

<p>Referenced by <a class="el" href="RMA_8cpp_source.html#l00827">modeOfData()</a>.</p>

</div>
</div>
<a class="anchor" id="af979f3581dfc7f2a479db2bb221ec3e1"></a><!-- doxytag: member="RMA::estimateBgParam" ref="af979f3581dfc7f2a479db2bb221ec3e1" args="(std::vector&lt; float &gt; &amp;data, double *mu, double *sigma, double *alpha, int numBins=16384)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RMA::estimateBgParam </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBins</em> = <code>16384</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the parameters necesary to do the <a class="el" href="classRMA.html" title="Holds methods for computing the popular Robust Muliarray Average of Microarrays (RMA).">RMA</a> background subtraction. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>- all of the data for a given cel file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mu</em>&nbsp;</td><td>- pointer to parameter mu to be filled in by function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sigma</em>&nbsp;</td><td>- pointer to parameter sigma to be filled in by function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alpha</em>&nbsp;</td><td>- pointer to paramter alpha to be filled in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numBins</em>&nbsp;</td><td>- number of bins to use in denstiy. <a class="el" href="classRMA.html" title="Holds methods for computing the popular Robust Muliarray Average of Microarrays (RMA).">RMA</a> traditionally uses 16,384. It is essential that this number be a power of two. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="RMA_8cpp_source.html#l00909">909</a> of file <a class="el" href="RMA_8cpp_source.html">RMA.cpp</a>.</p>

<p>References <a class="el" href="RMA_8cpp_source.html#l00827">modeOfData()</a>, and <a class="el" href="Util_8h_source.html#l00164">Util::round()</a>.</p>

<p>Referenced by <a class="el" href="RMA_8cpp_source.html#l01065">backgroundCorrect()</a>, and <a class="el" href="RmaBgTran_8cpp_source.html#l00157">RmaBgTran::initializeData()</a>.</p>

</div>
</div>
<a class="anchor" id="a147abbdd7daffd1ca36be245b6071cd3"></a><!-- doxytag: member="RMA::fft" ref="a147abbdd7daffd1ca36be245b6071cd3" args="(std::vector&lt; float &gt; &amp;dat, bool inverse)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RMA::fft </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>doInverse</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Do a fast fourier transform on data. </p>
<p>Do a fast fourier transform on data using the Danielson-Lanczos algorithm.</p>
<p>Values in data vector will be overwritten with the results. The format of data must be that of real and imaginary numbers interleaved together. So if the real portion of the number is at index 0, the imaginary portion will be at index 1. The next real number is at index 2 and imaginary portion is at index 3, etc. The input data vector must be a power of two (i.e. 32, 64, 128, etc) if your data is not a power of two in length you must pad it with zeros. Be warned that this bit of code is not terribly user friendly and can be tough to work with.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dat</em>&nbsp;</td><td>- data of interest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inverse</em>&nbsp;</td><td>- should we perform the inverse fourier transform?</td></tr>
  </table>
  </dd>
</dl>
<p>Values in data vector will be overwritten with the results. The format of data must be that of real and imaginary numbers interleaved together. So if the real portion of the number is at index 0, the imaginary portion will be at index 1. The next real number is at index 2 and imaginary portion is at index 3, etc. The input data vector must be a power of two (i.e. 32, 64, 128, etc) if your data is not a power of two in length you must pad it with zeros. Be warned that this bit of code is not terribly user friendly and can be tough to work with.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>- data of interest with interleaving real and imaginary portions. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>doInverse</em>&nbsp;</td><td>- should we perform the inverse fourier transform? </td></tr>
  </table>
  </dd>
</dl>

<p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000283">Todo:</a></b></dt><dd>This check looks ok, but on some hardware very small deviations make the floor and ceil fail </dd></dl>
</p>

<p>Definition at line <a class="el" href="RMA_8cpp_source.html#l01095">1095</a> of file <a class="el" href="RMA_8cpp_source.html">RMA.cpp</a>.</p>

<p>Referenced by <a class="el" href="RMA_8cpp_source.html#l00658">convolveDataKernel()</a>.</p>

</div>
</div>
<a class="anchor" id="a6ca4697cbf7e4e48fa7a3ee3e2e7f115"></a><!-- doxytag: member="RMA::findBandWidth" ref="a6ca4697cbf7e4e48fa7a3ee3e2e7f115" args="(std::vector&lt; float &gt; &amp;dat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double RMA::findBandWidth </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dat</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the bw.nrd0() function in R to decide kernel bandwidth. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dat</em>&nbsp;</td><td>- vector of data of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>- Bandwidth of kernel to use. </dd></dl>

<p>Definition at line <a class="el" href="RMA_8cpp_source.html#l00577">577</a> of file <a class="el" href="RMA_8cpp_source.html">RMA.cpp</a>.</p>

<p>References <a class="el" href="Verbose_8cpp_source.html#l00259">Verbose::out()</a>, <a class="el" href="RMA_8cpp_source.html#l00528">vectorIqr()</a>, and <a class="el" href="RMA_8cpp_source.html#l00477">vectorVariance()</a>.</p>

<p>Referenced by <a class="el" href="RMA_8cpp_source.html#l00827">modeOfData()</a>.</p>

</div>
</div>
<a class="anchor" id="ad0b693b6847cee2a00733e0e060143f1"></a><!-- doxytag: member="RMA::getColEffect" ref="ad0b693b6847cee2a00733e0e060143f1" args="(std::vector&lt; std::vector&lt; float &gt; &gt; &amp;psMatrix, int numRow, int numCol, std::vector&lt; float &gt; &amp;colEffect)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RMA::getColEffect </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; float &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>psMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>colEffect</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the median for the columns. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psMatrix</em>&nbsp;</td><td>- matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numRow</em>&nbsp;</td><td>- number of rows in matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numCol</em>&nbsp;</td><td>- number of columns in matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colEffect</em>&nbsp;</td><td>- fill in column effect. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="RMA_8cpp_source.html#l00140">140</a> of file <a class="el" href="RMA_8cpp_source.html">RMA.cpp</a>.</p>

<p>Referenced by <a class="el" href="RMA_8cpp_source.html#l00195">medianPolishPsetFromMatrix()</a>, and <a class="el" href="RMA_8cpp_source.html#l00318">medianPolishWithPrecomputedEffectsUsedAsSeedValues()</a>.</p>

</div>
</div>
<a class="anchor" id="a50ad140c16af79df52b4001d59457080"></a><!-- doxytag: member="RMA::getRanks" ref="a50ad140c16af79df52b4001d59457080" args="(struct _rmaPair *pairs, int count, std::vector&lt; int &gt; &amp;ranks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RMA::getRanks </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct__rmaPair.html">_rmaPair</a> *&nbsp;</td>
          <td class="paramname"> <em>pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>ranks</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the ranks of <a class="el" href="struct__rmaPair.html" title="Utility structure for sorting by data, but remembering rank.">_rmaPair</a> structures using the same algorthim as R to break ties. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pairs</em>&nbsp;</td><td>- array of <a class="el" href="struct__rmaPair.html" title="Utility structure for sorting by data, but remembering rank.">_rmaPair</a> strucutres. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>- size of array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ranks</em>&nbsp;</td><td>- vector of ranks. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="RMA_8cpp_source.html#l01194">1194</a> of file <a class="el" href="RMA_8cpp_source.html">RMA.cpp</a>.</p>

<p>References <a class="el" href="RMA_8cpp_source.html#l01162">_rmaPair::data</a>.</p>

<p>Referenced by <a class="el" href="RMA_8cpp_source.html#l01219">quantileNorm()</a>.</p>

</div>
</div>
<a class="anchor" id="ad8ba6f24a1b32e431541c4d17bb02670"></a><!-- doxytag: member="RMA::getRowEffect" ref="ad8ba6f24a1b32e431541c4d17bb02670" args="(std::vector&lt; std::vector&lt; float &gt; &gt; &amp;psMatrix, int numRow, int numCol, std::vector&lt; float &gt; &amp;rowEffect)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RMA::getRowEffect </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; float &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>psMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rowEffect</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the median for the rows. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psMatrix</em>&nbsp;</td><td>- matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numRow</em>&nbsp;</td><td>- number of rows in matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numCol</em>&nbsp;</td><td>- number of rows in matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rowEffect</em>&nbsp;</td><td>- fill in row effect.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>psMatrix</em>&nbsp;</td><td>- matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numRow</em>&nbsp;</td><td>- number of rows in matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numCol</em>&nbsp;</td><td>- number of rows in matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colEffect</em>&nbsp;</td><td>- fill in row effect. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="RMA_8cpp_source.html#l00089">89</a> of file <a class="el" href="RMA_8cpp_source.html">RMA.cpp</a>.</p>

<p>Referenced by <a class="el" href="RMA_8cpp_source.html#l00195">medianPolishPsetFromMatrix()</a>, <a class="el" href="RMA_8cpp_source.html#l00422">medianPolishWithPrecomputedEffectsOnePass()</a>, and <a class="el" href="RMA_8cpp_source.html#l00318">medianPolishWithPrecomputedEffectsUsedAsSeedValues()</a>.</p>

</div>
</div>
<a class="anchor" id="aee708b4478e5fa43ba6258651ac368b9"></a><!-- doxytag: member="RMA::linearApprox" ref="aee708b4478e5fa43ba6258651ac368b9" args="(std::vector&lt; float &gt; &amp;x, std::vector&lt; float &gt; &amp;y, std::vector&lt; float &gt; &amp;xOut, std::vector&lt; float &gt; &amp;yOut)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RMA::linearApprox </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>xOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>yOut</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Linearly interpolate x and y using values in x out. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>- vector 1 for interpolation from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>- vector 2 for interpolation to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>xOut</em>&nbsp;</td><td>- vector with data to interpolate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>yOut</em>&nbsp;</td><td>- output vector for interpolated data. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="RMA_8cpp_source.html#l00748">748</a> of file <a class="el" href="RMA_8cpp_source.html">RMA.cpp</a>.</p>

<p>References <a class="el" href="RMA_8cpp_source.html#l00704">linearInterpolate()</a>.</p>

<p>Referenced by <a class="el" href="RMA_8cpp_source.html#l00827">modeOfData()</a>.</p>

</div>
</div>
<a class="anchor" id="a113b790b81c3f863e6b2ab1350ebae4f"></a><!-- doxytag: member="RMA::linearInterpolate" ref="a113b790b81c3f863e6b2ab1350ebae4f" args="(double d, std::vector&lt; float &gt; &amp;x, std::vector&lt; float &gt; &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double RMA::linearInterpolate </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the interpolation for value d between x and y. </p>
<p>Assumes that x and y are sorted.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>d</em>&nbsp;</td><td>- value to interpolate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>- vector 1 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>- vector 2</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>interpolation of d from x into y. </dd></dl>

<p>Definition at line <a class="el" href="RMA_8cpp_source.html#l00704">704</a> of file <a class="el" href="RMA_8cpp_source.html">RMA.cpp</a>.</p>

<p>Referenced by <a class="el" href="RMA_8cpp_source.html#l00748">linearApprox()</a>.</p>

</div>
</div>
<a class="anchor" id="af2944caac48a0ca2eccd1082f54268aa"></a><!-- doxytag: member="RMA::matrixSum" ref="af2944caac48a0ca2eccd1082f54268aa" args="(std::vector&lt; std::vector&lt; float &gt; &gt; &amp;psMatrix, int numRow, int numCol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double RMA::matrixSum </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; float &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>psMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numCol</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the sum of a matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psMatrix</em>&nbsp;</td><td>- matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numRow</em>&nbsp;</td><td>- number of rows in matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numCol</em>&nbsp;</td><td>- number of columns in matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>sum of matrix. </dd></dl>

<p>Definition at line <a class="el" href="RMA_8cpp_source.html#l00169">169</a> of file <a class="el" href="RMA_8cpp_source.html">RMA.cpp</a>.</p>

<p>Referenced by <a class="el" href="RMA_8cpp_source.html#l00195">medianPolishPsetFromMatrix()</a>, and <a class="el" href="RMA_8cpp_source.html#l00318">medianPolishWithPrecomputedEffectsUsedAsSeedValues()</a>.</p>

</div>
</div>
<a class="anchor" id="a45f4c1b837663171147f237c2f24296f"></a><!-- doxytag: member="RMA::medianPolish" ref="a45f4c1b837663171147f237c2f24296f" args="(std::vector&lt; std::vector&lt; float &gt; &gt; &amp;pmMatrix, int numRow, int numCol, std::vector&lt; float &gt; &amp;colEstimates, std::vector&lt; float &gt; &amp;rowEstimates)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void RMA::medianPolish </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; float &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>pmMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>colEstimates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rowEstimates</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Static version of medianPolishSet for when it isn't convenient to have an <a class="el" href="classRMA.html" title="Holds methods for computing the popular Robust Muliarray Average of Microarrays (RMA).">RMA</a> instance. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pmMatrix</em>&nbsp;</td><td>- Matrix of perfect match probe intensities. Values will be modified in place, residuals will be filled in here. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numRow</em>&nbsp;</td><td>- Number of rows in the matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numCol</em>&nbsp;</td><td>- Number of columns in the matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>indexes</em>&nbsp;</td><td>- Indexes of the probes for probe set of interest into PM matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>results</em>&nbsp;</td><td>- Vector in which probe sets summaries, one per GeneChip, will be returned as log2 values. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="RMA_8h_source.html#l00110">110</a> of file <a class="el" href="RMA_8h_source.html">RMA.h</a>.</p>

<p>References <a class="el" href="RMA_8cpp_source.html#l00195">medianPolishPsetFromMatrix()</a>.</p>

</div>
</div>
<a class="anchor" id="a978989f98fa6719135cb9a020ded94c9"></a><!-- doxytag: member="RMA::medianPolishPSet" ref="a978989f98fa6719135cb9a020ded94c9" args="(const std::vector&lt; int &gt; &amp;indexes, std::vector&lt; float &gt; &amp;results)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RMA::medianPolishPSet </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>indexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>results</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use median polish to get a summary of probe set concentrations using probes that are at the row positions in PM specified by indexes. </p>
<p>results will be a vector with one summary value for each GeneChip for the probe set requested.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>indexes</em>&nbsp;</td><td>- Rows that are probes in the probe set of interest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>results</em>&nbsp;</td><td>- Vector in which probe sets summaries, one per GeneChip, will be returned as log2 values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac711699260fac62869e75aa3155c2f1a"></a><!-- doxytag: member="RMA::medianPolishPsetFromMatrix" ref="ac711699260fac62869e75aa3155c2f1a" args="(std::vector&lt; std::vector&lt; float &gt; &gt; &amp;pmMatrix, int numRow, int numCol, std::vector&lt; float &gt; &amp;colEstimates, std::vector&lt; float &gt; &amp;rowEstimates, bool doLog=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RMA::medianPolishPsetFromMatrix </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; float &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>pmMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>colEstimates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rowEstimates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>doLog</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Static version of medianPolishSet for when it isn't convenient to have an <a class="el" href="classRMA.html" title="Holds methods for computing the popular Robust Muliarray Average of Microarrays (RMA).">RMA</a> instance. </p>
<p>Note that both the the colEstimates and rowEstimates by convention have the global median added back to them. The identifiability function used by <a class="el" href="classRMA.html" title="Holds methods for computing the popular Robust Muliarray Average of Microarrays (RMA).">RMA</a> is median(log(f)) = 0 for both feature and target effects. By convention the global median is added back onto target estimates to avoid negative expression summaries. The same is done for feature effects although subtracting off the median for a probeset will give the median(log(f)) = 0 adjusted feature effects.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pmMatrix</em>&nbsp;</td><td>- Matrix of perfect match probe intensities. Values will be modified in place, residuals will be filled in here. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numRow</em>&nbsp;</td><td>- Number of rows in the matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numCol</em>&nbsp;</td><td>- Number of columns in the matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colEstimates</em>&nbsp;</td><td>- Feature effects. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rowEstimates</em>&nbsp;</td><td>- Target effects.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PM</em>&nbsp;</td><td>- Matrix of perfect match probe intensities. Values will be modified in place, residuals will be filled in here. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numRow</em>&nbsp;</td><td>- Number of rows in the matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numCol</em>&nbsp;</td><td>- Number of columns in the matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>indexes</em>&nbsp;</td><td>- Indexes of the probes for probe set of interest into PM matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>results</em>&nbsp;</td><td>- Vector in which probe sets summaries, one per GeneChip, will be returned. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="RMA_8cpp_source.html#l00195">195</a> of file <a class="el" href="RMA_8cpp_source.html">RMA.cpp</a>.</p>

<p>References <a class="el" href="snp_8label_8cpp_source.html#l00117">delta()</a>, <a class="el" href="Err_8cpp_source.html#l00068">Err::errAbort()</a>, <a class="el" href="RMA_8cpp_source.html#l00140">getColEffect()</a>, <a class="el" href="RMA_8cpp_source.html#l00089">getRowEffect()</a>, <a class="el" href="RMA_8cpp_source.html#l00169">matrixSum()</a>, <a class="el" href="RMA_8cpp_source.html#l00118">subColEffect()</a>, and <a class="el" href="RMA_8cpp_source.html#l00068">subRowEffect()</a>.</p>

<p>Referenced by <a class="el" href="QuantRma_8cpp_source.html#l00106">QuantRma::computeEstimate()</a>, and <a class="el" href="RMA_8h_source.html#l00110">medianPolish()</a>.</p>

</div>
</div>
<a class="anchor" id="a7f5bef27ec32e7e24c12c9cfd15299d1"></a><!-- doxytag: member="RMA::medianPolishWithPrecomputedEffectsOnePass" ref="a7f5bef27ec32e7e24c12c9cfd15299d1" args="(std::vector&lt; std::vector&lt; float &gt; &gt; &amp;pmMatrix, int numChips, int numProbes, std::vector&lt; float &gt; &amp;colEstimates, std::vector&lt; float &gt; &amp;rowEstimates, bool doLog=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RMA::medianPolishWithPrecomputedEffectsOnePass </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; float &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>pmMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numChips</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numProbes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>colEstimates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rowEstimates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>doLog</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Static version of medianPolishWithPrecomputedEffectsOnePass This version will use precomputed feature effects as input values and perform the usual median polish algorithm until convergence. </p>
<p>Static version of medianPolishWithPrecomputedEffects.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pmMatrix</em>&nbsp;</td><td>- Matrix of perfect match probe intensities. Values will be modified in place, residuals will be filled in here. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numRow</em>&nbsp;</td><td>- Number of rows in the matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numCol</em>&nbsp;</td><td>- Number of columns in the matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colEstimates</em>&nbsp;</td><td>- This is the precomputed vector of probe (feature) effects. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rowEstimates</em>&nbsp;</td><td>- This is the output vector of chip effects. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>doLog</em>&nbsp;</td><td>- This is a boolean switch to turn on or off the computation of logs of the input matrix.</td></tr>
  </table>
  </dd>
</dl>
<p>This version does the last steps of the usual median-polish algorithm but does not iterate until convergence. If the feature effects that are used have been generated from the same data on which the analysis is done, the chip effect values will not change.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pmMatrix</em>&nbsp;</td><td>- Matrix of perfect match probe intensities. Values will be modified in place, residuals will be filled in here. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numRow</em>&nbsp;</td><td>- Number of rows in the matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numCol</em>&nbsp;</td><td>- Number of columns in the matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colEstimates</em>&nbsp;</td><td>- This is the precomputed vector of probe (feature) effects. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rowEstimates</em>&nbsp;</td><td>- This is the output vector of chip effects. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>doLog</em>&nbsp;</td><td>- This is a boolean switch to turn on or off the computation of logs of the input matrix. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="RMA_8cpp_source.html#l00422">422</a> of file <a class="el" href="RMA_8cpp_source.html">RMA.cpp</a>.</p>

<p>References <a class="el" href="snp_8label_8cpp_source.html#l00117">delta()</a>, <a class="el" href="Err_8cpp_source.html#l00068">Err::errAbort()</a>, <a class="el" href="RMA_8cpp_source.html#l00089">getRowEffect()</a>, and <a class="el" href="RMA_8cpp_source.html#l00118">subColEffect()</a>.</p>

<p>Referenced by <a class="el" href="QuantRma_8cpp_source.html#l00106">QuantRma::computeEstimate()</a>.</p>

</div>
</div>
<a class="anchor" id="ab03b10f51a1f3cbf4e0564d46c13238b"></a><!-- doxytag: member="RMA::medianPolishWithPrecomputedEffectsUsedAsSeedValues" ref="ab03b10f51a1f3cbf4e0564d46c13238b" args="(std::vector&lt; std::vector&lt; float &gt; &gt; &amp;pmMatrix, int numChips, int numProbes, std::vector&lt; float &gt; &amp;colEstimates, std::vector&lt; float &gt; &amp;rowEstimates, bool doLog=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RMA::medianPolishWithPrecomputedEffectsUsedAsSeedValues </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; float &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>pmMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>colEstimates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rowEstimates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>doLog</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Static version of medianPolishWithPrecomputedEffectsUsedAsSeedValues This version will use precomputed feature effects as input values and perform the usual median polish algorithm until convergence. </p>
<p>Static version of medianPolish.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pmMatrix</em>&nbsp;</td><td>- Matrix of perfect match probe intensities. Values will be modified in place, residuals will be filled in here. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numRow</em>&nbsp;</td><td>- Number of rows in the matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numCol</em>&nbsp;</td><td>- Number of columns in the matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colEstimates</em>&nbsp;</td><td>- This is the precomputed vector of probe (feature) effects. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rowEstimates</em>&nbsp;</td><td>- This is the output vector of chip effects. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>doLog</em>&nbsp;</td><td>- This is a boolean switch to turn on or off the computation of logs of the input matrix.</td></tr>
  </table>
  </dd>
</dl>
<p>In this version precomputed values are used as seed values to the usual median-polish algorithm. It is allowed to run until the usual convergence criterion are met.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>PM</em>&nbsp;</td><td>- Matrix of perfect match probe intensities. Values will be modified in place, residuals will be filled in here. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numRow</em>&nbsp;</td><td>- Number of rows in the matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numCol</em>&nbsp;</td><td>- Number of columns in the matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>indexes</em>&nbsp;</td><td>- Indexes of the probes for probe set of interest into PM matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>results</em>&nbsp;</td><td>- Vector in which probe sets summaries, one per GeneChip, will be returned. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="RMA_8cpp_source.html#l00318">318</a> of file <a class="el" href="RMA_8cpp_source.html">RMA.cpp</a>.</p>

<p>References <a class="el" href="snp_8label_8cpp_source.html#l00117">delta()</a>, <a class="el" href="Err_8cpp_source.html#l00068">Err::errAbort()</a>, <a class="el" href="RMA_8cpp_source.html#l00140">getColEffect()</a>, <a class="el" href="RMA_8cpp_source.html#l00089">getRowEffect()</a>, <a class="el" href="RMA_8cpp_source.html#l00169">matrixSum()</a>, <a class="el" href="RMA_8cpp_source.html#l00118">subColEffect()</a>, and <a class="el" href="RMA_8cpp_source.html#l00068">subRowEffect()</a>.</p>

<p>Referenced by <a class="el" href="QuantRma_8cpp_source.html#l00106">QuantRma::computeEstimate()</a>.</p>

</div>
</div>
<a class="anchor" id="af4e7490905030f1fa1f380320c91693e"></a><!-- doxytag: member="RMA::modeOfData" ref="af4e7490905030f1fa1f380320c91693e" args="(std::vector&lt; float &gt; &amp;dat, int numBins)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double RMA::modeOfData </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBins</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Here we are recreating the density() function in R with an Epanechnikov kernel. </p>
<p>There are three steps 1) Compute a Epanechikov kernel. 2) Convolve the mass distribution with a fast fourier transform. 3) Linearly interpolate the results. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dat</em>&nbsp;</td><td>- data of interest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numBins</em>&nbsp;</td><td>- number of bins to spread data over (16384 for original <a class="el" href="classRMA.html" title="Holds methods for computing the popular Robust Muliarray Average of Microarrays (RMA).">RMA</a> method).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>- Mode of the data. </dd></dl>

<p>Definition at line <a class="el" href="RMA_8cpp_source.html#l00827">827</a> of file <a class="el" href="RMA_8cpp_source.html">RMA.cpp</a>.</p>

<p>References <a class="el" href="RMA_8cpp_source.html#l00608">colMassDist()</a>, <a class="el" href="RMA_8cpp_source.html#l00658">convolveDataKernel()</a>, <a class="el" href="RMA_8cpp_source.html#l00577">findBandWidth()</a>, <a class="el" href="RMA_8cpp_source.html#l00748">linearApprox()</a>, <a class="el" href="RMA_8cpp_source.html#l00559">vectorMax()</a>, and <a class="el" href="RMA_8cpp_source.html#l00541">vectorMin()</a>.</p>

<p>Referenced by <a class="el" href="RMA_8cpp_source.html#l00909">estimateBgParam()</a>.</p>

</div>
</div>
<a class="anchor" id="a81cabb33227ea30643a91132be491e13"></a><!-- doxytag: member="RMA::phi" ref="a81cabb33227ea30643a91132be491e13" args="(double x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double RMA::phi </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Standard normal probability density function. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>- value of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>- density at value supplied. Specifically: 1/sqrt(2*pi)*exp(-0.5*x^2)</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>- value of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>- density at value supplied </dd></dl>

<p>Definition at line <a class="el" href="RMA_8cpp_source.html#l00968">968</a> of file <a class="el" href="RMA_8cpp_source.html">RMA.cpp</a>.</p>

<p>Referenced by <a class="el" href="RMA_8h_source.html#l00341">bgSubData()</a>.</p>

</div>
</div>
<a class="anchor" id="aa9169b59f0b3d2677c17a273d4788f44"></a><!-- doxytag: member="RMA::PHI" ref="aa9169b59f0b3d2677c17a273d4788f44" args="(double x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double RMA::PHI </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The cdf function for standard normal distribution consistant with Bolstad's <a class="el" href="classRMA.html" title="Holds methods for computing the popular Robust Muliarray Average of Microarrays (RMA).">RMA</a> notatation. </p>
<p>The cdf function for standard normal distribution.</p>
<p>Also see pnorm. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>- value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>- probability that standard normal value has probability &lt;= x.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>- value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>- probability that standard normal value has probability &lt;= x. </dd></dl>

<p>Definition at line <a class="el" href="RMA_8cpp_source.html#l00959">959</a> of file <a class="el" href="RMA_8cpp_source.html">RMA.cpp</a>.</p>

<p>References <a class="el" href="RMA_8cpp_source.html#l00978">pnorm()</a>.</p>

</div>
</div>
<a class="anchor" id="a8ea065c5a07bad418069eff2e5336f99"></a><!-- doxytag: member="RMA::pnorm" ref="a8ea065c5a07bad418069eff2e5336f99" args="(double z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double RMA::pnorm </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>u</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cumulative standard normal density function. </p>
<p>Cumulative normal density function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>z</em>&nbsp;</td><td>- value for which to calculate the distribution function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>- probability that value is &lt; z.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>u</em>&nbsp;</td><td>- value for which to calculate the distribution function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>- probability that value is &lt; u. </dd></dl>

<p>Definition at line <a class="el" href="RMA_8cpp_source.html#l00978">978</a> of file <a class="el" href="RMA_8cpp_source.html">RMA.cpp</a>.</p>

<p>Referenced by <a class="el" href="RMA_8h_source.html#l00341">bgSubData()</a>, and <a class="el" href="RMA_8cpp_source.html#l00959">PHI()</a>.</p>

</div>
</div>
<a class="anchor" id="ae035731f10d7df8b91c248685a714315"></a><!-- doxytag: member="RMA::quantileNorm" ref="ae035731f10d7df8b91c248685a714315" args="(std::vector&lt; std::vector&lt; float &gt; &gt; &amp;data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RMA::quantileNorm </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; float &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Quantile Norm data using same algorithm to break ties as <a class="el" href="classRMA.html" title="Holds methods for computing the popular Robust Muliarray Average of Microarrays (RMA).">RMA</a> This function is deprecated as normalization sdk module now supports bioconductor style quantile normalization. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>- matrix of data. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="RMA_8cpp_source.html#l01219">1219</a> of file <a class="el" href="RMA_8cpp_source.html">RMA.cpp</a>.</p>

<p>References <a class="el" href="RMA_8cpp_source.html#l01162">_rmaPair::data</a>, <a class="el" href="Err_8cpp_source.html#l00068">Err::errAbort()</a>, <a class="el" href="RMA_8cpp_source.html#l01194">getRanks()</a>, and <a class="el" href="RMA_8cpp_source.html#l01163">_rmaPair::rank</a>.</p>

</div>
</div>
<a class="anchor" id="a765dc04890b9a824bac0b8efa057558c"></a><!-- doxytag: member="RMA::subColEffect" ref="a765dc04890b9a824bac0b8efa057558c" args="(std::vector&lt; std::vector&lt; float &gt; &gt; &amp;psMatrix, int numRow, int numCol, std::vector&lt; float &gt; &amp;colEffect)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RMA::subColEffect </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; float &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>psMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>colEffect</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subtract the median off of each column. </p>
<p>Subtract the median off of each row.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psMatrix</em>&nbsp;</td><td>- matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numRow</em>&nbsp;</td><td>- number of rows. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numCol</em>&nbsp;</td><td>- number of columns. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colEffect</em>&nbsp;</td><td>- values to subtract from each column.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>psMatrix</em>&nbsp;</td><td>- matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numRow</em>&nbsp;</td><td>- number of rows. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numCol</em>&nbsp;</td><td>- number of columns. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rowEffect</em>&nbsp;</td><td>- values to subtract from each row. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="RMA_8cpp_source.html#l00118">118</a> of file <a class="el" href="RMA_8cpp_source.html">RMA.cpp</a>.</p>

<p>Referenced by <a class="el" href="RMA_8cpp_source.html#l00195">medianPolishPsetFromMatrix()</a>, <a class="el" href="RMA_8cpp_source.html#l00422">medianPolishWithPrecomputedEffectsOnePass()</a>, and <a class="el" href="RMA_8cpp_source.html#l00318">medianPolishWithPrecomputedEffectsUsedAsSeedValues()</a>.</p>

</div>
</div>
<a class="anchor" id="af3857969e5a7b87ed1592221d43b4820"></a><!-- doxytag: member="RMA::subRowEffect" ref="af3857969e5a7b87ed1592221d43b4820" args="(std::vector&lt; std::vector&lt; float &gt; &gt; &amp;psMatrix, int numRow, int numCol, std::vector&lt; float &gt; &amp;rowEffect)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RMA::subRowEffect </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; float &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>psMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rowEffect</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subtract the median off of each row. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>psMatrix</em>&nbsp;</td><td>- matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numRow</em>&nbsp;</td><td>- number of rows. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numCol</em>&nbsp;</td><td>- number of columns. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rowEffect</em>&nbsp;</td><td>- values to subtract from each row. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="RMA_8cpp_source.html#l00068">68</a> of file <a class="el" href="RMA_8cpp_source.html">RMA.cpp</a>.</p>

<p>Referenced by <a class="el" href="RMA_8cpp_source.html#l00195">medianPolishPsetFromMatrix()</a>, and <a class="el" href="RMA_8cpp_source.html#l00318">medianPolishWithPrecomputedEffectsUsedAsSeedValues()</a>.</p>

</div>
</div>
<a class="anchor" id="a7ebecfa33f4983b4c8c5e6bc83eee11e"></a><!-- doxytag: member="RMA::vectorIqr" ref="a7ebecfa33f4983b4c8c5e6bc83eee11e" args="(std::vector&lt; float &gt; &amp;dat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double RMA::vectorIqr </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dat</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the range of values from .75 quantile to .25 quantile. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dat</em>&nbsp;</td><td>- Data of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>- difference between .75 and .25 quantiles. </dd></dl>

<p>Definition at line <a class="el" href="RMA_8cpp_source.html#l00528">528</a> of file <a class="el" href="RMA_8cpp_source.html">RMA.cpp</a>.</p>

<p>References <a class="el" href="RMA_8cpp_source.html#l00499">vectorQuantile()</a>.</p>

<p>Referenced by <a class="el" href="RMA_8cpp_source.html#l00577">findBandWidth()</a>.</p>

</div>
</div>
<a class="anchor" id="ac3b15107b4f1280fa8590950d2be2c4a"></a><!-- doxytag: member="RMA::vectorMax" ref="ac3b15107b4f1280fa8590950d2be2c4a" args="(std::vector&lt; float &gt; &amp;dat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double RMA::vectorMax </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dat</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the maximum value in a vector. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dat</em>&nbsp;</td><td>- vector of data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>maximum value. </dd></dl>

<p>Definition at line <a class="el" href="RMA_8cpp_source.html#l00559">559</a> of file <a class="el" href="RMA_8cpp_source.html">RMA.cpp</a>.</p>

<p>Referenced by <a class="el" href="RMA_8cpp_source.html#l00608">colMassDist()</a>, and <a class="el" href="RMA_8cpp_source.html#l00827">modeOfData()</a>.</p>

</div>
</div>
<a class="anchor" id="afbe09798d6421471fa47cbd6bfe72768"></a><!-- doxytag: member="RMA::vectorMean" ref="afbe09798d6421471fa47cbd6bfe72768" args="(std::vector&lt; float &gt; &amp;dat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double RMA::vectorMean </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dat</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the mean of a given vector. </p>
<p>sum(column)/n </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dat</em>&nbsp;</td><td>- vector of doubles to take average of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>- mean value of vector </dd></dl>

<p>Definition at line <a class="el" href="RMA_8cpp_source.html#l00461">461</a> of file <a class="el" href="RMA_8cpp_source.html">RMA.cpp</a>.</p>

<p>Referenced by <a class="el" href="RMA_8cpp_source.html#l00477">vectorVariance()</a>.</p>

</div>
</div>
<a class="anchor" id="ac30f9a0a0257c5bb05b0ec498a3987ce"></a><!-- doxytag: member="RMA::vectorMin" ref="ac30f9a0a0257c5bb05b0ec498a3987ce" args="(std::vector&lt; float &gt; &amp;dat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double RMA::vectorMin </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dat</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the minimum value in a vector. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dat</em>&nbsp;</td><td>- vector of data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>minimum value. </dd></dl>

<p>Definition at line <a class="el" href="RMA_8cpp_source.html#l00541">541</a> of file <a class="el" href="RMA_8cpp_source.html">RMA.cpp</a>.</p>

<p>Referenced by <a class="el" href="RMA_8cpp_source.html#l00608">colMassDist()</a>, and <a class="el" href="RMA_8cpp_source.html#l00827">modeOfData()</a>.</p>

</div>
</div>
<a class="anchor" id="a9dfdce9f02290fa2cf1e7902f29fc114"></a><!-- doxytag: member="RMA::vectorQuantile" ref="a9dfdce9f02290fa2cf1e7902f29fc114" args="(std::vector&lt; float &gt; &amp;dat, double quantile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double RMA::vectorQuantile </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>quantile</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the value at a particular quantile, Example quantile would be .5 which is equivalent to the median. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dat</em>&nbsp;</td><td>- Data of interest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>quantile</em>&nbsp;</td><td>- Quantile of interest to report between [0,1]; </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>value at quantile. </dd></dl>

<p>Definition at line <a class="el" href="RMA_8cpp_source.html#l00499">499</a> of file <a class="el" href="RMA_8cpp_source.html">RMA.cpp</a>.</p>

<p>Referenced by <a class="el" href="RMA_8cpp_source.html#l00528">vectorIqr()</a>.</p>

</div>
</div>
<a class="anchor" id="a0cbda20b31e8bdf7ee016787467cdb97"></a><!-- doxytag: member="RMA::vectorVariance" ref="a0cbda20b31e8bdf7ee016787467cdb97" args="(std::vector&lt; float &gt; &amp;dat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double RMA::vectorVariance </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>dat</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the variance of a given column. </p>
<p>(sum(average - actual))^2 / n-1 </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dat</em>&nbsp;</td><td>- vector of doubles to take variance of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>- variance of vectorn </dd></dl>

<p>Definition at line <a class="el" href="RMA_8cpp_source.html#l00477">477</a> of file <a class="el" href="RMA_8cpp_source.html">RMA.cpp</a>.</p>

<p>References <a class="el" href="RMA_8cpp_source.html#l00461">vectorMean()</a>.</p>

<p>Referenced by <a class="el" href="RMA_8cpp_source.html#l00577">findBandWidth()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>rma/<a class="el" href="RMA_8h_source.html">RMA.h</a></li>
<li>rma/<a class="el" href="RMA_8cpp_source.html">RMA.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jul 15 2014 10:38:21 for Affymetrix Power Tools by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
