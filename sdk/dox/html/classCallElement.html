<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Affymetrix Power Tools: CallElement Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a>  </div>
  <div class="headertitle">
<h1>CallElement Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="CallElement" -->
<p><a href="classCallElement-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallElement.html#a704af93ecb9fecf446601d24bb845f32">CallElement</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classCallElement.html#a704af93ecb9fecf446601d24bb845f32" title="CallElement::CallElement() Synopsis:">CallElement::CallElement()</a> Synopsis:  <a href="#a704af93ecb9fecf446601d24bb845f32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallElement.html#ab6c956550467cc07a3438ba86f3df1cc">CallElement</a> (const std::string &amp;probeSet, const std::string &amp;base, const unsigned int copyNumber=2, const bool hasRevComp=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classCallElement.html#a704af93ecb9fecf446601d24bb845f32" title="CallElement::CallElement() Synopsis:">CallElement::CallElement()</a> Synopsis: <a class="el" href="classGenotypeTableModel.html">GenotypeTableModel</a> (CHP) version of the <a class="el" href="classCallElement.html">CallElement</a> constructor.  <a href="#ab6c956550467cc07a3438ba86f3df1cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallElement.html#acf23c352ad8a4d08210e7b3861c6ccd1">addBase</a> (const std::string &amp;base)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classCallElement.html#acf23c352ad8a4d08210e7b3861c6ccd1" title="CallElement::addBase Synopsis:">CallElement::addBase</a> Synopsis:  <a href="#acf23c352ad8a4d08210e7b3861c6ccd1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallElement.html#ab4b0d7783df79ad49e86014a1851f716">basesToString</a> (bool reverseComplement=false) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classCallElement.html#ab4b0d7783df79ad49e86014a1851f716" title="CallElement::basesToString Synopsis:">CallElement::basesToString</a> Synopsis:  <a href="#ab4b0d7783df79ad49e86014a1851f716"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallElement.html#ad48b53fbcc77dd559afcf3eac6f0d4a9">describeVerbose</a> (const <a class="el" href="classRunTimeEnvironment.html">RunTimeEnvironment</a> &amp;rte, ADT_VERBOSE_ENUM override=ADT_VERBOSE_NULL) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classCallElement.html#ad48b53fbcc77dd559afcf3eac6f0d4a9" title="CallElement::describeVerbose Synopsis:">CallElement::describeVerbose</a> Synopsis:  <a href="#ad48b53fbcc77dd559afcf3eac6f0d4a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3dc616d94dfb23443e7ff655dc7644ad"></a><!-- doxytag: member="CallElement::describeVerbose" ref="a3dc616d94dfb23443e7ff655dc7644ad" args="(ADT_VERBOSE_ENUM level) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>describeVerbose</b> (ADT_VERBOSE_ENUM level) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b45a3b5a0a72dc09ed7e2a9b0fb7bf0"></a><!-- doxytag: member="CallElement::getCompleteSetSize" ref="a8b45a3b5a0a72dc09ed7e2a9b0fb7bf0" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>getCompleteSetSize</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallElement.html#a0de6ac38b62e4c2d38df828936ff1e56">isValidBase</a> (const std::string &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classCallElement.html#a0de6ac38b62e4c2d38df828936ff1e56" title="CallElement::isValidBase Synopsis:">CallElement::isValidBase</a> Synopsis:  <a href="#a0de6ac38b62e4c2d38df828936ff1e56"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallElement.html#a3be72de57ed495b597172677609841de">isValidProbeSet</a> (const std::string &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classCallElement.html#a3be72de57ed495b597172677609841de" title="CallElement::isValidProbeSet Synopsis:">CallElement::isValidProbeSet</a> Synopsis:  <a href="#a3be72de57ed495b597172677609841de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallElement.html#a5aeff74fc7d30cf9f2828fb1dac76df2">setCompleteSetSize</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classCallElement.html#a5aeff74fc7d30cf9f2828fb1dac76df2" title="CallElement::setCompleteSetSize Synopsis:">CallElement::setCompleteSetSize</a> Synopsis:  <a href="#a5aeff74fc7d30cf9f2828fb1dac76df2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d51b54b97e657870379914adf2ed2b3"></a><!-- doxytag: member="CallElement::hasWildCards" ref="a6d51b54b97e657870379914adf2ed2b3" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>hasWildCards</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallElement.html#afea01adea5d36818ed700dfab20a4abb">operator==</a> (<a class="el" href="classCallElement.html">CallElement</a> const &amp;) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classCallElement.html#afea01adea5d36818ed700dfab20a4abb" title="CallElement::operator== Synopsis:">CallElement::operator==</a> Synopsis:  <a href="#afea01adea5d36818ed700dfab20a4abb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00c233115505073f894075c677627915"></a><!-- doxytag: member="CallElement::operator!=" ref="a00c233115505073f894075c677627915" args="(CallElement const &amp;b) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (<a class="el" href="classCallElement.html">CallElement</a> const &amp;b) const </td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallElement.html#aae6a8be2dfee570fe4ddd451cb8a74c3">isWildCardBase</a> (std::string base)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classCallElement.html#aae6a8be2dfee570fe4ddd451cb8a74c3" title="CallElement::isWildCardBase Synopsis:">CallElement::isWildCardBase</a> Synopsis:  <a href="#aae6a8be2dfee570fe4ddd451cb8a74c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallElement.html#a11386b2d1d7a7a2497f51a3112567f9a">reverseComplement</a> (const std::string seq)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classCallElement.html#a11386b2d1d7a7a2497f51a3112567f9a" title="CallElement::reverseComplement.">CallElement::reverseComplement</a>.  <a href="#a11386b2d1d7a7a2497f51a3112567f9a"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93d8a454817bc2b8eb7ece76d0ad57d2"></a><!-- doxytag: member="CallElement::m_bases" ref="a93d8a454817bc2b8eb7ece76d0ad57d2" args="" -->
std::vector&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>m_bases</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3161e1c77bae2b5f8363eea818b9ae65"></a><!-- doxytag: member="CallElement::m_chromatid" ref="a3161e1c77bae2b5f8363eea818b9ae65" args="" -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><b>m_chromatid</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a41cf725a95abe51300229e71ed9cb1"></a><!-- doxytag: member="CallElement::m_copyNumber" ref="a6a41cf725a95abe51300229e71ed9cb1" args="" -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><b>m_copyNumber</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45d2cae1d34a78dc8a839319d3084abf"></a><!-- doxytag: member="CallElement::m_hasReverseComplement" ref="a45d2cae1d34a78dc8a839319d3084abf" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>m_hasReverseComplement</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad080eb0b2ff92d8686ad16acaa39307c"></a><!-- doxytag: member="CallElement::m_probeSet" ref="ad080eb0b2ff92d8686ad16acaa39307c" args="" -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><b>m_probeSet</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ed5addef77c72f12a7189f48ccf4687"></a><!-- doxytag: member="CallElement::m_rbases" ref="a4ed5addef77c72f12a7189f48ccf4687" args="" -->
std::vector&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>m_rbases</b></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>

<p>Definition at line <a class="el" href="CallElement_8h_source.html#l00041">41</a> of file <a class="el" href="CallElement_8h_source.html">CallElement.h</a>.</p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a704af93ecb9fecf446601d24bb845f32"></a><!-- doxytag: member="CallElement::CallElement" ref="a704af93ecb9fecf446601d24bb845f32" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CallElement::CallElement </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classCallElement.html#a704af93ecb9fecf446601d24bb845f32" title="CallElement::CallElement() Synopsis:">CallElement::CallElement()</a> Synopsis: </p>
<p>Empty constructor for STL storage containers or for translation file call elements.</p>
<p>NOTE: base is used interchangabley to mean allele. In DMET 2 alleles where always represented as just one base. </p>

<p>Definition at line <a class="el" href="CallElement_8cpp_source.html#l00052">52</a> of file <a class="el" href="CallElement_8cpp_source.html">CallElement.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab6c956550467cc07a3438ba86f3df1cc"></a><!-- doxytag: member="CallElement::CallElement" ref="ab6c956550467cc07a3438ba86f3df1cc" args="(const std::string &amp;probeSet, const std::string &amp;base, const unsigned int copyNumber=2, const bool hasRevComp=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CallElement::CallElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>probeSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&nbsp;</td>
          <td class="paramname"> <em>copyNumber</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>hasRevComp</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classCallElement.html#a704af93ecb9fecf446601d24bb845f32" title="CallElement::CallElement() Synopsis:">CallElement::CallElement()</a> Synopsis: <a class="el" href="classGenotypeTableModel.html">GenotypeTableModel</a> (CHP) version of the <a class="el" href="classCallElement.html">CallElement</a> constructor. </p>
<p>This is not obvious but when a <a class="el" href="classCallElement.html">CallElement</a> is created for the <a class="el" href="classGenotypeTableModel.html">GenotypeTableModel</a>, it will always have exactly one base. Multiple bases only apply to mult-allelic defintions in the Translation table.</p>
<p>NOTE: base is used interchangabley to mean allele. In DMET two alleles where always represented as just one base.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>probeSet</em>&nbsp;</td><td>- aka "marker", ie.e AM_14633, etc. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>base</em>&nbsp;</td><td>- aka "alleles", A, or ATATGGA. For multiallelic markers intialize with one base and then append markers using <a class="el" href="classCallElement.html#acf23c352ad8a4d08210e7b3861c6ccd1" title="CallElement::addBase Synopsis:">CallElement::addBase()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>copyNumber</em>&nbsp;</td><td>- 2 by default. 0 and 1 are the only other legal values. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hasRevComp</em>&nbsp;</td><td>- reverse complement, if the "Switch" field in translation file or annotation file is "Y/1" then the reverse compliment of the base will be used durring translation. See "CallElement::reverseComplement". </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="CallElement_8cpp_source.html#l00088">88</a> of file <a class="el" href="CallElement_8cpp_source.html">CallElement.cpp</a>.</p>

<p>References <a class="el" href="CallElement_8cpp_source.html#l00125">addBase()</a>, <a class="el" href="Err_8h_source.html#l00050">APT_ERR_ABORT</a>, <a class="el" href="Err_8h_source.html#l00054">APT_ERR_ASSERT</a>, <a class="el" href="CallElement_8cpp_source.html#l00322">isValidBase()</a>, <a class="el" href="CallElement_8cpp_source.html#l00296">isValidProbeSet()</a>, and <a class="el" href="CallElement_8cpp_source.html#l00352">isWildCardBase()</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="acf23c352ad8a4d08210e7b3861c6ccd1"></a><!-- doxytag: member="CallElement::addBase" ref="acf23c352ad8a4d08210e7b3861c6ccd1" args="(const std::string &amp;base)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CallElement::addBase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>base</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classCallElement.html#acf23c352ad8a4d08210e7b3861c6ccd1" title="CallElement::addBase Synopsis:">CallElement::addBase</a> Synopsis: </p>
<p>Append a base (allele) to the std::vector of bases (alleles). Insure the added base is not a duplicate as well that the base is valid. Also adds the passed in base to its reverse complement list if the element the 'hasReverseComplement' attribute is true;</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>base</em>&nbsp;</td><td>- the base to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true - if base was added successfully. </dd></dl>

<p>Definition at line <a class="el" href="CallElement_8cpp_source.html#l00125">125</a> of file <a class="el" href="CallElement_8cpp_source.html">CallElement.cpp</a>.</p>

<p>References <a class="el" href="CallElement_8cpp_source.html#l00322">isValidBase()</a>, and <a class="el" href="CallElement_8cpp_source.html#l00432">reverseComplement()</a>.</p>

<p>Referenced by <a class="el" href="CallSet_8cpp_source.html#l00188">CallSet::addCallElement()</a>, and <a class="el" href="CallElement_8cpp_source.html#l00088">CallElement()</a>.</p>

</div>
</div>
<a class="anchor" id="ab4b0d7783df79ad49e86014a1851f716"></a><!-- doxytag: member="CallElement::basesToString" ref="ab4b0d7783df79ad49e86014a1851f716" args="(bool reverseComplement=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string CallElement::basesToString </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>reverseComplement</em> = <code>false</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classCallElement.html#ab4b0d7783df79ad49e86014a1851f716" title="CallElement::basesToString Synopsis:">CallElement::basesToString</a> Synopsis: </p>
<p>Return a list of the bases (alleles) for this <a class="el" href="classCallElement.html">CallElement</a> as a comma separated list. For most bi-allelic markers in the translation table the list size will be one.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reverseComplement</em>&nbsp;</td><td>- return the list of reverse complements and not the original bases (alleles).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>basesString - i.e. "A,T,G". </dd></dl>

<p>Definition at line <a class="el" href="CallElement_8cpp_source.html#l00165">165</a> of file <a class="el" href="CallElement_8cpp_source.html">CallElement.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad48b53fbcc77dd559afcf3eac6f0d4a9"></a><!-- doxytag: member="CallElement::describeVerbose" ref="ad48b53fbcc77dd559afcf3eac6f0d4a9" args="(const RunTimeEnvironment &amp;rte, ADT_VERBOSE_ENUM override=ADT_VERBOSE_NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CallElement::describeVerbose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRunTimeEnvironment.html">RunTimeEnvironment</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ADT_VERBOSE_ENUM&nbsp;</td>
          <td class="paramname"> <em>override</em> = <code>ADT_VERBOSE_NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classCallElement.html#ad48b53fbcc77dd559afcf3eac6f0d4a9" title="CallElement::describeVerbose Synopsis:">CallElement::describeVerbose</a> Synopsis: </p>
<p>Run time debug routine that can be invoked with various verbose levels. ADT_VERBOSE_INPUT_FILES is the default level.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rte</em>&nbsp;</td><td>- run time environment </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>override</em>&nbsp;</td><td>- ADT_VERBOSE_INPUT_FILES by default, otherwise the ADT_VERBOSE_ENUM level to output </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="CallElement_8cpp_source.html#l00242">242</a> of file <a class="el" href="CallElement_8cpp_source.html">CallElement.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0de6ac38b62e4c2d38df828936ff1e56"></a><!-- doxytag: member="CallElement::isValidBase" ref="a0de6ac38b62e4c2d38df828936ff1e56" args="(const std::string &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CallElement::isValidBase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>testBase</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classCallElement.html#a0de6ac38b62e4c2d38df828936ff1e56" title="CallElement::isValidBase Synopsis:">CallElement::isValidBase</a> Synopsis: </p>
<p>Regular expression test to examine if a base (allele) is valid. Wildcard designations such as "PossibleRareAllele" and "NoCall" are handled correctly and will return true.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>testBase</em>&nbsp;</td><td>- the base (allele) std::string to validate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>- true if valid </dd></dl>

<p>Definition at line <a class="el" href="CallElement_8cpp_source.html#l00322">322</a> of file <a class="el" href="CallElement_8cpp_source.html">CallElement.cpp</a>.</p>

<p>References <a class="el" href="CallElement_8cpp_source.html#l00352">isWildCardBase()</a>.</p>

<p>Referenced by <a class="el" href="CallElement_8cpp_source.html#l00125">addBase()</a>, and <a class="el" href="CallElement_8cpp_source.html#l00088">CallElement()</a>.</p>

</div>
</div>
<a class="anchor" id="a3be72de57ed495b597172677609841de"></a><!-- doxytag: member="CallElement::isValidProbeSet" ref="a3be72de57ed495b597172677609841de" args="(const std::string &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CallElement::isValidProbeSet </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>testProbeSet</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classCallElement.html#a3be72de57ed495b597172677609841de" title="CallElement::isValidProbeSet Synopsis:">CallElement::isValidProbeSet</a> Synopsis: </p>
<p>Regular expression test to examine if a probe set (marker) std::string is valid.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>testProbeSet</em>&nbsp;</td><td>- the std::string to validate</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true - if valid </dd></dl>

<p>Definition at line <a class="el" href="CallElement_8cpp_source.html#l00296">296</a> of file <a class="el" href="CallElement_8cpp_source.html">CallElement.cpp</a>.</p>

<p>Referenced by <a class="el" href="CallElement_8cpp_source.html#l00088">CallElement()</a>.</p>

</div>
</div>
<a class="anchor" id="aae6a8be2dfee570fe4ddd451cb8a74c3"></a><!-- doxytag: member="CallElement::isWildCardBase" ref="aae6a8be2dfee570fe4ddd451cb8a74c3" args="(std::string base)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CallElement::isWildCardBase </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>base</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classCallElement.html#aae6a8be2dfee570fe4ddd451cb8a74c3" title="CallElement::isWildCardBase Synopsis:">CallElement::isWildCardBase</a> Synopsis: </p>
<p>Regular exxpression test to examine if a base (allele) is a wild card.</p>
<p>Wildcard list: 1.) NoCall (NC) 2.) PossibleRareAllele (PRA) 3.) NotAvailable</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>base</em>&nbsp;</td><td>- the base (allele) to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true - if the base (allele) is a wild card. </dd></dl>

<p>Definition at line <a class="el" href="CallElement_8cpp_source.html#l00352">352</a> of file <a class="el" href="CallElement_8cpp_source.html">CallElement.cpp</a>.</p>

<p>Referenced by <a class="el" href="CallSet_8cpp_source.html#l00188">CallSet::addCallElement()</a>, <a class="el" href="CallElement_8cpp_source.html#l00088">CallElement()</a>, <a class="el" href="CallSet_8cpp_source.html#l00093">CallSet::CallSet()</a>, <a class="el" href="GenotypeOverrideTableModel_8cpp_source.html#l00134">GenotypeOverrideTableModel::GenotypeOverrideTableModel()</a>, <a class="el" href="CallElement_8cpp_source.html#l00322">isValidBase()</a>, <a class="el" href="CallElement_8cpp_source.html#l00392">operator==()</a>, and <a class="el" href="CallElement_8cpp_source.html#l00432">reverseComplement()</a>.</p>

</div>
</div>
<a class="anchor" id="afea01adea5d36818ed700dfab20a4abb"></a><!-- doxytag: member="CallElement::operator==" ref="afea01adea5d36818ed700dfab20a4abb" args="(CallElement const &amp;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CallElement::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCallElement.html">CallElement</a> const &amp;&nbsp;</td>
          <td class="paramname"> <em>ce1</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classCallElement.html#afea01adea5d36818ed700dfab20a4abb" title="CallElement::operator== Synopsis:">CallElement::operator==</a> Synopsis: </p>
<p>The purpose of the <a class="el" href="classCallElement.html">CallElement</a> class is to provide this one operator.</p>
<p>This operator treats the probe set (marker) id and a corresponding list of bases (alleles) as an atomic unit.</p>
<p>Comparing call elements as equivalent means the atomic consituents must also be equivalent according to a set of rules.</p>
<p>Business rules treat no call and possible rare allele as wildcards that match any base. It also compares multi-allelic CallElements and if they share a common base then they are equal. Note that for CallElements derived from the Genotype Short Report data they can never be multi-allelic. This means that the only multi-allelic <a class="el" href="classCallElement.html">CallElement</a> being compared will be the Translation Table file <a class="el" href="classCallElement.html">CallElement</a> with the <a class="el" href="classGenotypeTableModel.html">GenotypeTableModel</a> (CHP) <a class="el" href="classCallElement.html">CallElement</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ce1</em>&nbsp;</td><td>- the <a class="el" href="classCallElement.html">CallElement</a> to compare</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true - if equal. </dd></dl>

<p>Definition at line <a class="el" href="CallElement_8cpp_source.html#l00392">392</a> of file <a class="el" href="CallElement_8cpp_source.html">CallElement.cpp</a>.</p>

<p>References <a class="el" href="CallElement_8cpp_source.html#l00352">isWildCardBase()</a>.</p>

</div>
</div>
<a class="anchor" id="a11386b2d1d7a7a2497f51a3112567f9a"></a><!-- doxytag: member="CallElement::reverseComplement" ref="a11386b2d1d7a7a2497f51a3112567f9a" args="(const std::string seq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string CallElement::reverseComplement </td>
          <td>(</td>
          <td class="paramtype">const std::string&nbsp;</td>
          <td class="paramname"> <em>seq</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classCallElement.html#a11386b2d1d7a7a2497f51a3112567f9a" title="CallElement::reverseComplement.">CallElement::reverseComplement</a>. </p>
<p>Synopsis:</p>
<p>Switch to the other strand by taking the reverse complement.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>seq</em>&nbsp;</td><td>- the base (allele) sequence to take the complement of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>rev - the reverse complement </dd></dl>

<p>Definition at line <a class="el" href="CallElement_8cpp_source.html#l00432">432</a> of file <a class="el" href="CallElement_8cpp_source.html">CallElement.cpp</a>.</p>

<p>References <a class="el" href="CallElement_8cpp_source.html#l00352">isWildCardBase()</a>.</p>

<p>Referenced by <a class="el" href="CallElement_8cpp_source.html#l00125">addBase()</a>, and <a class="el" href="TranslationTableModel_8cpp_source.html#l00907">TranslationTableModel::setReportAlleles()</a>.</p>

</div>
</div>
<a class="anchor" id="a5aeff74fc7d30cf9f2828fb1dac76df2"></a><!-- doxytag: member="CallElement::setCompleteSetSize" ref="a5aeff74fc7d30cf9f2828fb1dac76df2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CallElement::setCompleteSetSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classCallElement.html#a5aeff74fc7d30cf9f2828fb1dac76df2" title="CallElement::setCompleteSetSize Synopsis:">CallElement::setCompleteSetSize</a> Synopsis: </p>
<p>A <a class="el" href="classCallElement.html">CallElement</a> typically represents one marker, but in one special case the complete call element set represents all alleles (bases) possible for a marker. This API is used in that one special case to get the complete set size. The complete set size is used in the translation algorithm.</p>
<p>Complete set size, n: 1 The count of all allels (bases) minus any copy number bases.</p>
<p>return size - the count </p>

<p>Definition at line <a class="el" href="CallElement_8cpp_source.html#l00212">212</a> of file <a class="el" href="CallElement_8cpp_source.html">CallElement.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>translation/<a class="el" href="CallElement_8h_source.html">CallElement.h</a></li>
<li>translation/<a class="el" href="CallElement_8cpp_source.html">CallElement.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jul 15 2014 10:38:02 for Affymetrix Power Tools by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
