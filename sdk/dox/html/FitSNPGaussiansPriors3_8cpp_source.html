<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Affymetrix Power Tools: birdseed-dev/FitSNPGaussiansPriors3.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="dir_1b57070bf6bfc6917e3b423824da5473.html">birdseed-dev</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>FitSNPGaussiansPriors3.cpp</h1>  </div>
</div>
<div class="contents">
<a href="FitSNPGaussiansPriors3_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">////////////////////////////////////////////////////////////////</span>
<a name="l00002"></a>00002 <span class="comment"></span><span class="comment">//</span>
<a name="l00003"></a>00003 <span class="comment">// Copyright (C) 2007 The Broad Institute and Affymetrix, Inc.</span>
<a name="l00004"></a>00004 <span class="comment">//</span>
<a name="l00005"></a>00005 <span class="comment">// This program is free software; you can redistribute it and/or modify </span>
<a name="l00006"></a>00006 <span class="comment">// it under the terms of the GNU General Public License (version 2) as </span>
<a name="l00007"></a>00007 <span class="comment">// published by the Free Software Foundation.</span>
<a name="l00008"></a>00008 <span class="comment">// </span>
<a name="l00009"></a>00009 <span class="comment">// This program is distributed in the hope that it will be useful, </span>
<a name="l00010"></a>00010 <span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of </span>
<a name="l00011"></a>00011 <span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU </span>
<a name="l00012"></a>00012 <span class="comment">// General Public License for more details.</span>
<a name="l00013"></a>00013 <span class="comment">// </span>
<a name="l00014"></a>00014 <span class="comment">// You should have received a copy of the GNU General Public License </span>
<a name="l00015"></a>00015 <span class="comment">// along with this program;if not, write to the </span>
<a name="l00016"></a>00016 <span class="comment">// </span>
<a name="l00017"></a>00017 <span class="comment">// Free Software Foundation, Inc., </span>
<a name="l00018"></a>00018 <span class="comment">// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<a name="l00019"></a>00019 <span class="comment">//</span><span class="comment"></span>
<a name="l00020"></a>00020 <span class="comment">////////////////////////////////////////////////////////////////</span>
<a name="l00021"></a>00021 <span class="comment"></span><span class="comment"></span>
<a name="l00022"></a>00022 <span class="comment">/// @file FitSNPGaussiansPriors3.cpp</span>
<a name="l00023"></a>00023 <span class="comment"></span>
<a name="l00024"></a>00024 <span class="comment">//</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;birdseed-dev/FitSNPGaussiansPriors3.h&quot;</span>
<a name="l00026"></a>00026 <span class="comment">//</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;birdseed-dev/Matrix.h&quot;</span>
<a name="l00028"></a>00028 <span class="comment">//</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;broadutil/APTUtil.h&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;broadutil/BroadUtil.h&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;<a class="code" href="SelfCreate_8h.html" title="Small interface for functions that know how to make an instance of themselves given a map of key...">chipstream/SelfCreate.h</a>&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;<a class="code" href="SelfDoc_8h.html" title="Small interface to for algorithmic classes that can explain themselves.">chipstream/SelfDoc.h</a>&quot;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;<a class="code" href="PgOptions_8h.html" title="Classes for reading program command line options.">util/PgOptions.h</a>&quot;</span>
<a name="l00034"></a>00034 <span class="comment">//</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;algorithm&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;cassert&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;cmath&gt;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;limits&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &lt;memory&gt;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00042"></a>00042 <span class="comment">//</span>
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 <span class="keyword">using namespace </span>std;
<a name="l00045"></a>00045 <span class="keyword">using namespace </span>birdseed::dev;
<a name="l00046"></a>00046 
<a name="l00047"></a>00047 <span class="comment">// See below for documentation of these parameters.</span>
<a name="l00048"></a>00048 <span class="keyword">static</span> <span class="keywordtype">double</span> std_slope;
<a name="l00049"></a>00049 <span class="keyword">static</span> <span class="keywordtype">double</span> epsilon;
<a name="l00050"></a>00050 <span class="keyword">static</span> <span class="keywordtype">double</span> eps;
<a name="l00051"></a>00051 <span class="keyword">static</span> <span class="keywordtype">double</span> var_start;
<a name="l00052"></a>00052 <span class="keyword">static</span> <span class="keywordtype">double</span> cluster_distance_ratio_cutoff;
<a name="l00053"></a>00053 <span class="comment">// TODO: Consider removing this, and removing tempmeandist, and lambda3</span>
<a name="l00054"></a>00054 <span class="keyword">static</span> <span class="keywordtype">double</span> mean_dist2;
<a name="l00055"></a>00055 <span class="keyword">static</span> <span class="keywordtype">double</span> lambda3;
<a name="l00056"></a>00056 <span class="keyword">static</span> <span class="keywordtype">double</span> merged_cluster_threshold;
<a name="l00057"></a>00057 <span class="keyword">static</span> <span class="keywordtype">double</span> small_cluster_weight_threshold;
<a name="l00058"></a>00058 <span class="keyword">static</span> <span class="keywordtype">double</span> expected_wingspan_ratio;
<a name="l00059"></a>00059 <span class="keyword">static</span> <span class="keywordtype">double</span> low_hom_weight_fraction;
<a name="l00060"></a>00060 <span class="keyword">static</span> <span class="keywordtype">double</span> low_hom_sample_inflation;
<a name="l00061"></a>00061 <span class="keyword">static</span> <span class="keywordtype">double</span> starting_cluster_weight;
<a name="l00062"></a>00062 <span class="keyword">static</span> <span class="keywordtype">size_t</span> max_iter;
<a name="l00063"></a>00063 <span class="keyword">static</span> <span class="keywordtype">double</span> min_covar;
<a name="l00064"></a>00064 <span class="keyword">static</span> <span class="keywordtype">double</span> max_covar1;
<a name="l00065"></a>00065 <span class="keyword">static</span> <span class="keywordtype">double</span> max_covar2;
<a name="l00066"></a>00066 <span class="keyword">static</span> <span class="keywordtype">double</span> covar_floor_decay;
<a name="l00067"></a>00067 <span class="keyword">static</span> <span class="keywordtype">double</span> low_covar_threshold;
<a name="l00068"></a>00068 <span class="keyword">static</span> <span class="keywordtype">double</span> wing_length_delta_penalty;
<a name="l00069"></a>00069 <span class="keyword">static</span> <span class="keywordtype">double</span> small_cluster_penalty;
<a name="l00070"></a>00070 <span class="keyword">static</span> <span class="keywordtype">double</span> unbalanced_wingspan_penalty;
<a name="l00071"></a>00071 <span class="keyword">static</span> <span class="keywordtype">double</span> low_covar_penalty;
<a name="l00072"></a>00072 <span class="keyword">static</span> <span class="keywordtype">double</span> bic_weight;
<a name="l00073"></a>00073 <span class="keyword">static</span> <span class="keywordtype">double</span> anchor_weight;
<a name="l00074"></a>00074 <span class="keyword">static</span> <span class="keywordtype">double</span> max_anchor_percentage;
<a name="l00075"></a>00075 <span class="comment">// Not static because used by GenotypeCaller</span>
<a name="l00076"></a>00076 <span class="keywordtype">double</span> birdseed::dev::final_weight_min;
<a name="l00077"></a>00077 <span class="keyword">static</span> <span class="keywordtype">double</span> cluster_variance_regularization_factor;
<a name="l00078"></a>00078 <span class="keyword">static</span> <span class="keywordtype">double</span> var_mult;
<a name="l00079"></a>00079 <span class="keyword">static</span> <span class="keywordtype">bool</span>  allow_unlikely_clusters;
<a name="l00080"></a>00080 <span class="keyword">static</span> <span class="keywordtype">double</span> hom_hom_penalty;
<a name="l00081"></a>00081 <span class="keyword">static</span> <span class="keywordtype">double</span> mono_het_penalty;
<a name="l00082"></a>00082 <span class="keyword">static</span> <span class="keywordtype">double</span> two_cluster_low_observation_penalty_factor;
<a name="l00083"></a>00083 <span class="comment">// This is not static because GenotypeCaller uses it.</span>
<a name="l00084"></a>00084 <span class="keywordtype">double</span> birdseed::dev::relative_distance_confidence_weight;
<a name="l00085"></a>00085 <span class="keyword">static</span> <span class="keywordtype">double</span> std_inflection_point;
<a name="l00086"></a>00086 
<a name="l00087"></a>00087 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> special = <span class="keyword">true</span>;
<a name="l00088"></a>00088 
<a name="l00089"></a>00089 <span class="preprocessor">#ifdef _MSC_VER</span>
<a name="l00090"></a>00090 <span class="preprocessor"></span><span class="preprocessor">#define log(value) log((double)value)</span>
<a name="l00091"></a>00091 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00092"></a>00092 <span class="preprocessor"></span>
<a name="l00093"></a>00093 <span class="preprocessor">#ifdef __sun__</span>
<a name="l00094"></a>00094 <span class="preprocessor"></span><span class="preprocessor">#define log(value) log((double)value)</span>
<a name="l00095"></a>00095 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00096"></a>00096 <span class="preprocessor"></span>
<a name="l00097"></a>00097 <span class="comment">// This class translates between the local parameters in this file and PgOptions world.</span>
<a name="l00098"></a>00098 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00099"></a><a class="code" href="classOptionSpec.html">00099</a> <span class="keyword">class </span><a class="code" href="classOptionSpec.html">OptionSpec</a>
<a name="l00100"></a>00100 {
<a name="l00101"></a>00101   <span class="keyword">public</span>:
<a name="l00102"></a>00102     T *targetVariable;
<a name="l00103"></a>00103     <a class="code" href="classPgOpt.html" title="///">PgOpt</a> pgOpt;
<a name="l00104"></a>00104     <a class="code" href="classSelfDoc_1_1Opt.html" title="Description of one possible option/parameter for a self describing class.">SelfDoc::Opt</a> selfDocOpt;
<a name="l00105"></a>00105     <a class="code" href="classOptionSpec.html">OptionSpec</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *longName, T *targetVariable, T defaultValue, <span class="keyword">const</span> <span class="keywordtype">char</span> *defaultValueAsString, <span class="keyword">const</span> <span class="keywordtype">char</span> *helpDoc, <a class="code" href="classPgOpt.html#a2d7a96bff0c8aed58fbb2520f37a2248" title="Types of allowed options.">PgOpt::PgOptType_t</a> optType, <span class="keywordtype">bool</span> makeSelfDocOpt):
<a name="l00106"></a>00106         targetVariable(targetVariable),
<a name="l00107"></a>00107         pgOpt()
<a name="l00108"></a>00108     {
<a name="l00109"></a>00109         pgOpt.m_shortName = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00110"></a>00110         pgOpt.m_longName = longName;
<a name="l00111"></a>00111         pgOpt.m_type = optType;
<a name="l00112"></a>00112         pgOpt.m_help = helpDoc;
<a name="l00113"></a>00113         pgOpt.m_defaultValue = defaultValueAsString;
<a name="l00114"></a>00114         *targetVariable = defaultValue;
<a name="l00115"></a>00115         <span class="keywordflow">if</span> (makeSelfDocOpt) {
<a name="l00116"></a>00116             selfDocOpt.name = longName;
<a name="l00117"></a>00117             selfDocOpt.value = defaultValueAsString;
<a name="l00118"></a>00118             selfDocOpt.defaultVal = defaultValueAsString;
<a name="l00119"></a>00119             selfDocOpt.minVal = <span class="stringliteral">&quot;NA&quot;</span>;
<a name="l00120"></a>00120             selfDocOpt.maxVal = <span class="stringliteral">&quot;NA&quot;</span>;
<a name="l00121"></a>00121             selfDocOpt.descript = helpDoc;
<a name="l00122"></a>00122             <span class="keywordflow">switch</span> (optType) {
<a name="l00123"></a>00123             <span class="keywordflow">case</span> PgOpt::BOOL_OPT:
<a name="l00124"></a>00124                 selfDocOpt.type = SelfDoc::Opt::Boolean;
<a name="l00125"></a>00125                 <span class="keywordflow">break</span>;
<a name="l00126"></a>00126             <span class="keywordflow">case</span> PgOpt::INT_OPT:
<a name="l00127"></a>00127                 selfDocOpt.type = SelfDoc::Opt::Integer;
<a name="l00128"></a>00128                 <span class="keywordflow">break</span>;
<a name="l00129"></a>00129             <span class="keywordflow">case</span> PgOpt::DOUBLE_OPT:
<a name="l00130"></a>00130                 selfDocOpt.type = SelfDoc::Opt::Double;
<a name="l00131"></a>00131                 <span class="keywordflow">break</span>;
<a name="l00132"></a>00132             <span class="keywordflow">default</span>:
<a name="l00133"></a>00133                 <span class="keywordflow">throw</span> <a class="code" href="classBroadException.html">BroadException</a>(<span class="stringliteral">&quot;Unrecognized option type&quot;</span>, __FILE__, __LINE__);
<a name="l00134"></a>00134                 <span class="keywordflow">break</span>;
<a name="l00135"></a>00135             }
<a name="l00136"></a>00136         }
<a name="l00137"></a>00137     }
<a name="l00138"></a>00138 };
<a name="l00139"></a>00139 
<a name="l00140"></a>00140 <span class="preprocessor">#define DEFINE_OPTION(TYPE, VAR_NAME, DEFAULT_VALUE, HELP_DOC, OPT_TYPE, MAKE_SELF_DOC) \</span>
<a name="l00141"></a>00141 <span class="preprocessor">    OptionSpec&lt;TYPE&gt;(#VAR_NAME, &amp;VAR_NAME, DEFAULT_VALUE, #DEFAULT_VALUE, HELP_DOC, OPT_TYPE, MAKE_SELF_DOC)</span>
<a name="l00142"></a>00142 <span class="preprocessor"></span><span class="preprocessor">#define DEFINE_DOUBLE_OPTION(VAR_NAME, DEFAULT_VALUE, HELP_DOC, MAKE_SELF_DOC) DEFINE_OPTION(double, VAR_NAME, DEFAULT_VALUE, HELP_DOC, PgOpt::DOUBLE_OPT, MAKE_SELF_DOC)</span>
<a name="l00143"></a>00143 <span class="preprocessor"></span>
<a name="l00144"></a>00144 <span class="keyword">static</span> <a class="code" href="classOptionSpec.html">OptionSpec&lt;double&gt;</a> doubleOptions[] = {
<a name="l00145"></a>00145     DEFINE_DOUBLE_OPTION(std_slope, 0.062, <span class="stringliteral">&quot;expected slope of cluster standard deviation versus cluster mean intensity.&quot;</span>, <span class="keyword">true</span>),
<a name="l00146"></a>00146     DEFINE_DOUBLE_OPTION(epsilon, 0.001, <span class="stringliteral">&quot;tolerance at which to stop optimizing cluster locations.&quot;</span>, <span class="keyword">true</span>),
<a name="l00147"></a>00147     DEFINE_DOUBLE_OPTION(eps, 0.00000000000000022204, <span class="stringliteral">&quot;a very small number.&quot;</span>, <span class="keyword">true</span>),
<a name="l00148"></a>00148     DEFINE_DOUBLE_OPTION(var_start, 1.1, <span class="stringliteral">&quot;intialize the variances to be var_start times the expected.&quot;</span>, <span class="keyword">true</span>),
<a name="l00149"></a>00149     DEFINE_DOUBLE_OPTION(cluster_distance_ratio_cutoff, 0.85, <span class="stringliteral">&quot;the ratio of adjacent cluster means in each direction must exceed this value.&quot;</span>, <span class="keyword">true</span>),
<a name="l00150"></a>00150     DEFINE_DOUBLE_OPTION(merged_cluster_threshold, .025, <span class="stringliteral">&quot;if two cluster means get this close to each other, consider them merged, and stop trying EM.&quot;</span>, <span class="keyword">true</span>),
<a name="l00151"></a>00151     DEFINE_DOUBLE_OPTION(small_cluster_weight_threshold, 0.01, <span class="stringliteral">&quot;if k==3, any weight&lt;small_cluster_weight_threshold, penalize ll with small_cluster_penalty.&quot;</span>, <span class="keyword">true</span>),
<a name="l00152"></a>00152         DEFINE_DOUBLE_OPTION(low_hom_weight_fraction, 0.5, <span class="stringliteral">&quot;Hom cluster should not have low weight.&quot;</span>, <span class="keyword">true</span>),
<a name="l00153"></a>00153         DEFINE_DOUBLE_OPTION(low_hom_sample_inflation, 100, <span class="stringliteral">&quot;Hom cluster should not have low weight.  Sample inflation factor.&quot;</span>, <span class="keyword">true</span>),
<a name="l00154"></a>00154         DEFINE_DOUBLE_OPTION(starting_cluster_weight,0.05, <span class="stringliteral">&quot;Starting weight for uninitialized clusters.&quot;</span>, <span class="keyword">true</span>),
<a name="l00155"></a>00155     DEFINE_DOUBLE_OPTION(small_cluster_penalty, 10.0, <span class="stringliteral">&quot;how much to penalize small clusters when k=3.&quot;</span>, <span class="keyword">true</span>),
<a name="l00156"></a>00156     DEFINE_DOUBLE_OPTION(expected_wingspan_ratio, 1.15, <span class="stringliteral">&quot;penalize ll if ratio of wing lengths is above this number.&quot;</span>, <span class="keyword">true</span>),
<a name="l00157"></a>00157     DEFINE_DOUBLE_OPTION(unbalanced_wingspan_penalty, 5.0, <span class="stringliteral">&quot;how much to penalize differences from expected_wingspan_ratio.&quot;</span>, <span class="keyword">true</span>),
<a name="l00158"></a>00158     DEFINE_DOUBLE_OPTION(min_covar, -0.7, <span class="stringliteral">&quot;don&#39;t let covar get lower than this.&quot;</span>, <span class="keyword">true</span>),
<a name="l00159"></a>00159         DEFINE_DOUBLE_OPTION(max_covar1, 0.9, <span class="stringliteral">&quot;covar1 not larger than this.&quot;</span>, <span class="keyword">true</span>),
<a name="l00160"></a>00160         DEFINE_DOUBLE_OPTION(max_covar2, 0.95,<span class="stringliteral">&quot;covar2 not larger than this.&quot;</span>, <span class="keyword">true</span>),
<a name="l00161"></a>00161         DEFINE_DOUBLE_OPTION(covar_floor_decay,8,<span class="stringliteral">&quot;Covariance decays over this iteration scale.&quot;</span>, <span class="keyword">true</span>),
<a name="l00162"></a>00162     DEFINE_DOUBLE_OPTION(low_covar_threshold, 1.0, <span class="stringliteral">&quot;penalize covariances below this number.&quot;</span>, <span class="keyword">true</span>),
<a name="l00163"></a>00163     DEFINE_DOUBLE_OPTION(low_covar_penalty, 15.0, <span class="stringliteral">&quot;how much to penalize covar below low_covar_threshold.&quot;</span>, <span class="keyword">true</span>),
<a name="l00164"></a>00164     DEFINE_DOUBLE_OPTION(wing_length_delta_penalty, 50.0, <span class="stringliteral">&quot;how much to penalize differences from the prior.&quot;</span>, <span class="keyword">true</span>),
<a name="l00165"></a>00165     DEFINE_DOUBLE_OPTION(bic_weight, 1.0, <span class="stringliteral">&quot;how much to penalize higher-order k&#39;s.&quot;</span>, <span class="keyword">true</span>),
<a name="l00166"></a>00166     DEFINE_DOUBLE_OPTION(anchor_weight, 1.0, <span class="stringliteral">&quot;how strongly to anchor clusters to the priors (using pseudocounts).&quot;</span>, <span class="keyword">true</span>),
<a name="l00167"></a>00167     DEFINE_DOUBLE_OPTION(max_anchor_percentage, 5.0, <span class="stringliteral">&quot;maximum strength of anchor to priors (as a percentage of samples in the cluster).&quot;</span>, <span class="keyword">true</span>),
<a name="l00168"></a>00168     DEFINE_DOUBLE_OPTION(final_weight_min, 0.333, <span class="stringliteral">&quot;After calculating clusters, ensure all weights are &gt;= this.&quot;</span>, <span class="keyword">true</span>),
<a name="l00169"></a>00169     DEFINE_DOUBLE_OPTION(cluster_variance_regularization_factor, 1.0, <span class="stringliteral">&quot;How much cluster variances are regularized to look like each other.&quot;</span>, <span class="keyword">true</span>),
<a name="l00170"></a>00170     DEFINE_DOUBLE_OPTION(var_mult, 1.2, <span class="stringliteral">&quot;Multiply the variance for missing clusters by this value squared.&quot;</span>, <span class="keyword">true</span>),
<a name="l00171"></a>00171     DEFINE_DOUBLE_OPTION(hom_hom_penalty, 2.1, <span class="stringliteral">&quot;Multiply the average distance between clusters and priors in 2-cluster model by this, when trying to fit clusters to hom priors.&quot;</span>, <span class="keyword">true</span>),
<a name="l00172"></a>00172     DEFINE_DOUBLE_OPTION(mono_het_penalty, 999999999, <span class="stringliteral">&quot;Multiply the distance squared between cluster and prior in 1-cluster model by this, when trying to fit single cluster to AB prior.&quot;</span>, <span class="keyword">true</span>),
<a name="l00173"></a>00173     DEFINE_DOUBLE_OPTION(two_cluster_low_observation_penalty_factor, 10, <span class="stringliteral">&quot;When penalizing an alignment of two-cluster model, use this factor to place a floor on penalty when number of prior observations for a prior is low.&quot;</span>, <span class="keyword">true</span>),
<a name="l00174"></a>00174     DEFINE_DOUBLE_OPTION(relative_distance_confidence_weight, 0.8, <span class="stringliteral">&quot;How much to weight confidence factor determined by comparing probability of best match vs. probability of second best match. Confidence factor determined by measuring distance of sample from cluster center is weighted by 1-this value.&quot;</span>, <span class="keyword">true</span>),
<a name="l00175"></a>00175     DEFINE_DOUBLE_OPTION(std_inflection_point, 4.0, <span class="stringliteral">&quot;Factor in determination of confidence based on distance of sample from cluster center.&quot;</span>, <span class="keyword">true</span>),
<a name="l00176"></a>00176 
<a name="l00177"></a>00177     DEFINE_DOUBLE_OPTION(mean_dist2, 1.2, <span class="stringliteral">&quot;if two means get this close, penalize ll by 3k*log(n)/2;.&quot;</span>, <span class="keyword">true</span>),
<a name="l00178"></a>00178     DEFINE_DOUBLE_OPTION(lambda3, 2.5, <span class="stringliteral">&quot;how much to penalize differences from mean_dist2.&quot;</span>, <span class="keyword">true</span>)
<a name="l00179"></a>00179 };
<a name="l00180"></a>00180 
<a name="l00181"></a>00181 <span class="keyword">static</span> <a class="code" href="classOptionSpec.html">OptionSpec&lt;size_t&gt;</a> size_tOptions[] = {
<a name="l00182"></a>00182     DEFINE_OPTION(<span class="keywordtype">size_t</span>, max_iter, 50, <span class="stringliteral">&quot;if it reaches more than max_iter/k iterations, just stop.&quot;</span>, PgOpt::INT_OPT, <span class="keyword">true</span>)
<a name="l00183"></a>00183 };
<a name="l00184"></a>00184 
<a name="l00185"></a>00185 <span class="keyword">static</span> <a class="code" href="classOptionSpec.html">OptionSpec&lt;bool&gt;</a> boolOptions[] = {
<a name="l00186"></a>00186     DEFINE_OPTION(<span class="keywordtype">bool</span>, allow_unlikely_clusters, <span class="keyword">true</span>, <span class="stringliteral">&quot;Allow 2-cluster model to match to AA &amp;&amp; BB priors, and allow 1-cluster model to match AB prior.&quot;</span>, PgOpt::BOOL_OPT, <span class="keyword">true</span>)
<a name="l00187"></a>00187 };
<a name="l00188"></a>00188 
<a name="l00189"></a>00189 
<a name="l00190"></a>00190 <span class="keyword">static</span> <a class="code" href="classPgOpt.html" title="///">PgOpt</a> *pgOptions[ARRAY_LEN(doubleOptions) + ARRAY_LEN(size_tOptions) + ARRAY_LEN(boolOptions) + 1];
<a name="l00191"></a>00191 
<a name="l00192"></a>00192 <span class="comment">// This class is here merely to get some static initializer code run, so that parameters get</span>
<a name="l00193"></a>00193 <span class="comment">// their default values, and the PgOpt array is initialized.</span>
<a name="l00194"></a>00194 <span class="keyword">static</span> <span class="keyword">class </span>PgOptionCreator
<a name="l00195"></a>00195 {
<a name="l00196"></a>00196   <span class="keyword">public</span>:
<a name="l00197"></a>00197     PgOptionCreator()
<a name="l00198"></a>00198     {
<a name="l00199"></a>00199         <a class="code" href="classPgOpt.html" title="///">PgOpt</a> **p = pgOptions;
<a name="l00200"></a>00200         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; ARRAY_LEN(doubleOptions); ++i) {
<a name="l00201"></a>00201             *p++ = &amp;doubleOptions[i].pgOpt;
<a name="l00202"></a>00202         }
<a name="l00203"></a>00203         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; ARRAY_LEN(size_tOptions); ++i) {
<a name="l00204"></a>00204             *p++ = &amp;size_tOptions[i].pgOpt;
<a name="l00205"></a>00205         }
<a name="l00206"></a>00206         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; ARRAY_LEN(boolOptions); ++i) {
<a name="l00207"></a>00207             *p++ = &amp;boolOptions[i].pgOpt;
<a name="l00208"></a>00208         }
<a name="l00209"></a>00209         *p = NULL;
<a name="l00210"></a>00210     }
<a name="l00211"></a>00211 } theOptionCreator;
<a name="l00212"></a>00212     
<a name="l00213"></a>00213 <a class="code" href="classPgOpt.html" title="///">PgOpt</a> **birdseed::dev::getAlgorithmicOpts()
<a name="l00214"></a>00214 {
<a name="l00215"></a>00215     <span class="keywordflow">return</span> pgOptions;
<a name="l00216"></a>00216 }
<a name="l00217"></a>00217 
<a name="l00218"></a>00218 <span class="keywordtype">void</span> birdseed::dev::setAlgorithmicParameters(CONSTHACK <a class="code" href="classPgOptions.html">PgOptions</a> &amp;opts)
<a name="l00219"></a>00219 {
<a name="l00220"></a>00220     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; ARRAY_LEN(doubleOptions); ++i) {
<a name="l00221"></a>00221         *doubleOptions[i].targetVariable = opts.getDouble(doubleOptions[i].pgOpt.<a class="code" href="classPgOpt.html#ab1f8f0e59dc492020ad0c772c6f215e4" title="Long name without the &amp;#39;--&amp;#39; prefix.">m_longName</a>);
<a name="l00222"></a>00222     }
<a name="l00223"></a>00223     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; ARRAY_LEN(size_tOptions); ++i) {
<a name="l00224"></a>00224         *size_tOptions[i].targetVariable = opts.getInt(size_tOptions[i].pgOpt.<a class="code" href="classPgOpt.html#ab1f8f0e59dc492020ad0c772c6f215e4" title="Long name without the &amp;#39;--&amp;#39; prefix.">m_longName</a>);
<a name="l00225"></a>00225     }
<a name="l00226"></a>00226     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; ARRAY_LEN(boolOptions); ++i) {
<a name="l00227"></a>00227         *boolOptions[i].targetVariable = opts.getBool(boolOptions[i].pgOpt.<a class="code" href="classPgOpt.html#ab1f8f0e59dc492020ad0c772c6f215e4" title="Long name without the &amp;#39;--&amp;#39; prefix.">m_longName</a>);
<a name="l00228"></a>00228     }
<a name="l00229"></a>00229 }
<a name="l00230"></a>00230 
<a name="l00231"></a>00231 <span class="keywordtype">void</span> birdseed::dev::getSelfDocOptions(vector&lt;SelfDoc::Opt&gt; *opts)
<a name="l00232"></a>00232 {
<a name="l00233"></a>00233     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; ARRAY_LEN(doubleOptions); ++i) {
<a name="l00234"></a>00234         <span class="keywordflow">if</span> (!doubleOptions[i].selfDocOpt.<a class="code" href="classSelfDoc_1_1Opt.html#a426ebf8e8ff3d2c027d63a17c7b3653b" title="Name of option.">name</a>.empty()) {
<a name="l00235"></a>00235             opts-&gt;push_back(doubleOptions[i].selfDocOpt);
<a name="l00236"></a>00236         }
<a name="l00237"></a>00237     }
<a name="l00238"></a>00238     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; ARRAY_LEN(size_tOptions); ++i) {
<a name="l00239"></a>00239         <span class="keywordflow">if</span> (!size_tOptions[i].selfDocOpt.<a class="code" href="classSelfDoc_1_1Opt.html#a426ebf8e8ff3d2c027d63a17c7b3653b" title="Name of option.">name</a>.empty()) {
<a name="l00240"></a>00240             opts-&gt;push_back(size_tOptions[i].selfDocOpt);
<a name="l00241"></a>00241         }
<a name="l00242"></a>00242     }
<a name="l00243"></a>00243     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; ARRAY_LEN(boolOptions); ++i) {
<a name="l00244"></a>00244         <span class="keywordflow">if</span> (!boolOptions[i].selfDocOpt.<a class="code" href="classSelfDoc_1_1Opt.html#a426ebf8e8ff3d2c027d63a17c7b3653b" title="Name of option.">name</a>.empty()) {
<a name="l00245"></a>00245             opts-&gt;push_back(boolOptions[i].selfDocOpt);
<a name="l00246"></a>00246         }
<a name="l00247"></a>00247     }
<a name="l00248"></a>00248 }
<a name="l00249"></a>00249 
<a name="l00250"></a>00250 <span class="keywordtype">void</span> birdseed::dev::setSelfDocOptions(<a class="code" href="classSelfDoc.html" title="Small interface to for algorithmic classes that can explain themselves.">SelfDoc</a> *doc, CONSTHACK std::map&lt;std::string,std::string&gt; &amp;param)
<a name="l00251"></a>00251 {
<a name="l00252"></a>00252     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; ARRAY_LEN(doubleOptions); ++i) {
<a name="l00253"></a>00253         <span class="keywordflow">if</span> (!doubleOptions[i].selfDocOpt.<a class="code" href="classSelfDoc_1_1Opt.html#a426ebf8e8ff3d2c027d63a17c7b3653b" title="Name of option.">name</a>.empty()) {
<a name="l00254"></a>00254             SelfCreate::fillInValue(*doubleOptions[i].targetVariable, doubleOptions[i].selfDocOpt.<a class="code" href="classSelfDoc_1_1Opt.html#a426ebf8e8ff3d2c027d63a17c7b3653b" title="Name of option.">name</a>, param, *doc);
<a name="l00255"></a>00255         }
<a name="l00256"></a>00256     }
<a name="l00257"></a>00257     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; ARRAY_LEN(size_tOptions); ++i) {
<a name="l00258"></a>00258         <span class="keywordflow">if</span> (!size_tOptions[i].selfDocOpt.<a class="code" href="classSelfDoc_1_1Opt.html#a426ebf8e8ff3d2c027d63a17c7b3653b" title="Name of option.">name</a>.empty()) {
<a name="l00259"></a>00259             <span class="keywordtype">int</span> value;
<a name="l00260"></a>00260             SelfCreate::fillInValue(value, size_tOptions[i].selfDocOpt.<a class="code" href="classSelfDoc_1_1Opt.html#a426ebf8e8ff3d2c027d63a17c7b3653b" title="Name of option.">name</a>, param, *doc);
<a name="l00261"></a>00261             *size_tOptions[i].targetVariable = value;
<a name="l00262"></a>00262         }
<a name="l00263"></a>00263     }
<a name="l00264"></a>00264     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; ARRAY_LEN(boolOptions); ++i) {
<a name="l00265"></a>00265         <span class="keywordflow">if</span> (!boolOptions[i].selfDocOpt.<a class="code" href="classSelfDoc_1_1Opt.html#a426ebf8e8ff3d2c027d63a17c7b3653b" title="Name of option.">name</a>.empty()) {
<a name="l00266"></a>00266             SelfCreate::fillInValue(*boolOptions[i].targetVariable, boolOptions[i].selfDocOpt.<a class="code" href="classSelfDoc_1_1Opt.html#a426ebf8e8ff3d2c027d63a17c7b3653b" title="Name of option.">name</a>, param, *doc);
<a name="l00267"></a>00267         }
<a name="l00268"></a>00268     }
<a name="l00269"></a>00269 }
<a name="l00270"></a>00270 
<a name="l00271"></a>00271 
<a name="l00272"></a>00272 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> diploidNumGaussians[] = {1, 2, 3, 3};
<a name="l00273"></a>00273 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> lenDiploidNumGaussians = ARRAY_SIZE(diploidNumGaussians);
<a name="l00274"></a>00274 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> haploidNumGaussians[] = {1, 2};
<a name="l00275"></a>00275 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> lenHaploidNumGaussians = ARRAY_SIZE(haploidNumGaussians);
<a name="l00276"></a>00276 
<a name="l00277"></a>00277 <span class="keyword">static</span> <span class="keywordtype">int</span> verbosity = 0;
<a name="l00278"></a>00278 
<a name="l00279"></a>00279 <span class="keywordtype">void</span> birdseed::dev::setFitSNPGaussiansVerbosity(<span class="keywordtype">int</span> verbose)
<a name="l00280"></a>00280 {
<a name="l00281"></a>00281     verbosity = verbose;
<a name="l00282"></a>00282 }
<a name="l00283"></a>00283 
<a name="l00284"></a>00284 <span class="keyword">static</span> <span class="keywordtype">double</span> computeStdInterceptPrior(<span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1Priors.html">Priors</a> &amp;priors, <span class="keywordtype">size_t</span> whichAllele)
<a name="l00285"></a>00285 {
<a name="l00286"></a>00286     <span class="keywordtype">double</span> numerator = 0.0;
<a name="l00287"></a>00287     <span class="keywordtype">size_t</span> denominator = 0;
<a name="l00288"></a>00288     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; priors.getNumPriors(); ++i) {
<a name="l00289"></a>00289         denominator += priors.getPrior(i).m_numObservations;
<a name="l00290"></a>00290         numerator += priors.getPrior(i).m_numObservations *
<a name="l00291"></a>00291             (sqrt(priors.getPrior(i).m_covarMatrix[whichAllele][whichAllele]) - std_slope * priors.getPrior(i).m_mean[whichAllele]);
<a name="l00292"></a>00292     }
<a name="l00293"></a>00293     <span class="keywordflow">return</span> numerator / denominator;
<a name="l00294"></a>00294 }
<a name="l00295"></a>00295 
<a name="l00296"></a>00296 <span class="keyword">static</span> <span class="keywordtype">double</span> determinant(<span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1FixedMatrix.html">Matrix2x2</a> &amp;mat)
<a name="l00297"></a>00297 {
<a name="l00298"></a>00298     <span class="keywordflow">return</span> mat[1][1]*mat[0][0] - mat[1][0]*mat[0][1];
<a name="l00299"></a>00299 }
<a name="l00300"></a>00300 
<a name="l00301"></a>00301 <span class="keyword">static</span> <a class="code" href="classbirdseed_1_1dev_1_1FixedMatrix.html">Matrix2x2</a> invert(<span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1FixedMatrix.html">Matrix2x2</a> &amp;inMatrix)
<a name="l00302"></a>00302 {
<a name="l00303"></a>00303     <a class="code" href="classbirdseed_1_1dev_1_1FixedMatrix.html">Matrix2x2</a> outMatrix;
<a name="l00304"></a>00304     <span class="keywordtype">double</span> det = determinant(inMatrix);
<a name="l00305"></a>00305     outMatrix[0][0] = inMatrix[1][1] / det;
<a name="l00306"></a>00306     outMatrix[1][1] = inMatrix[0][0] / det;
<a name="l00307"></a>00307     outMatrix[0][1] = -inMatrix[0][1] / det;
<a name="l00308"></a>00308     outMatrix[1][0] = -inMatrix[1][0] / det;
<a name="l00309"></a>00309     <span class="keywordflow">return</span> outMatrix;
<a name="l00310"></a>00310 }
<a name="l00311"></a>00311 
<a name="l00312"></a>00312 <span class="keyword">template</span>&lt;<span class="keyword">class</span> MATRIX, <span class="keyword">class</span> VECTOR&gt;
<a name="l00313"></a>00313 <span class="keyword">static</span> <a class="code" href="classbirdseed_1_1dev_1_1FixedMatrix.html">Matrix2x2</a> covariance(<span class="keyword">const</span> MATRIX &amp;<a class="code" href="classmatrix.html">matrix</a>, <span class="keyword">const</span> VECTOR &amp;means)
<a name="l00314"></a>00314 {
<a name="l00315"></a>00315     assert(means.size() == NUM_ALLELES);
<a name="l00316"></a>00316     assert(matrix.numCols() == NUM_ALLELES);
<a name="l00317"></a>00317     <a class="code" href="classbirdseed_1_1dev_1_1FixedMatrix.html">Matrix2x2</a> ret;
<a name="l00318"></a>00318     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; NUM_ALLELES; ++i) {
<a name="l00319"></a>00319         ret[i][i] = variance(matrix, means[i], i);
<a name="l00320"></a>00320     }
<a name="l00321"></a>00321     <span class="keywordtype">double</span> acc = 0.0;
<a name="l00322"></a>00322     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; matrix.numRows(); ++i) {
<a name="l00323"></a>00323         acc += (matrix[i][0] - means[0]) * (matrix[i][1] - means[1]);
<a name="l00324"></a>00324     }
<a name="l00325"></a>00325     ret[0][1] = ret[1][0] = acc / (matrix.numRows() - 1);
<a name="l00326"></a>00326     <span class="keywordflow">return</span> ret;
<a name="l00327"></a>00327 }
<a name="l00328"></a>00328 
<a name="l00329"></a>00329 <span class="keyword">template</span> &lt;<span class="keyword">class</span> MATRIX&gt;
<a name="l00330"></a>00330 <span class="keyword">static</span> MATRIX pow(<span class="keyword">const</span> MATRIX &amp;matrix, <span class="keyword">typename</span> MATRIX::value_type exponent)
<a name="l00331"></a>00331 {
<a name="l00332"></a>00332     MATRIX ret;
<a name="l00333"></a>00333     <span class="keywordflow">if</span> (exponent == 2) {
<a name="l00334"></a>00334         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> row = 0; row &lt; matrix.numRows(); ++row) {
<a name="l00335"></a>00335             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> col = 0; col &lt; matrix.numCols(); ++col) {
<a name="l00336"></a>00336                 ret[row][col] = matrix[row][col] * matrix[row][col];
<a name="l00337"></a>00337             }
<a name="l00338"></a>00338         }
<a name="l00339"></a>00339     }
<a name="l00340"></a>00340     <span class="keywordflow">else</span> {
<a name="l00341"></a>00341         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> row = 0; row &lt; matrix.numRows(); ++row) {
<a name="l00342"></a>00342             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> col = 0; col &lt; matrix.numCols(); ++col) {
<a name="l00343"></a>00343                 ret[row][col] = pow(matrix[row][col], exponent);
<a name="l00344"></a>00344             }
<a name="l00345"></a>00345         }
<a name="l00346"></a>00346     }
<a name="l00347"></a>00347     <span class="keywordflow">return</span> ret;
<a name="l00348"></a>00348 }
<a name="l00349"></a>00349 
<a name="l00350"></a>00350 <span class="keyword">template</span>&lt;<span class="keyword">class</span> VECTOR&gt;
<a name="l00351"></a>00351 <span class="keyword">static</span> VECTOR powVector(<span class="keyword">const</span> VECTOR &amp;vec, <span class="keyword">typename</span> VECTOR::value_type exponent)
<a name="l00352"></a>00352 {
<a name="l00353"></a>00353     VECTOR ret(vec.size());
<a name="l00354"></a>00354     <span class="keywordflow">if</span> (exponent == 2) {
<a name="l00355"></a>00355         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; vec.size(); ++i) {
<a name="l00356"></a>00356             ret[i] = vec[i] * vec[i];
<a name="l00357"></a>00357         }
<a name="l00358"></a>00358     }
<a name="l00359"></a>00359     <span class="keywordflow">else</span> {
<a name="l00360"></a>00360         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; vec.size(); ++i) {
<a name="l00361"></a>00361             ret[i] = pow(vec[i], exponent);
<a name="l00362"></a>00362         }
<a name="l00363"></a>00363     }
<a name="l00364"></a>00364     <span class="keywordflow">return</span> ret;
<a name="l00365"></a>00365 }
<a name="l00366"></a>00366 
<a name="l00367"></a>00367 
<a name="l00368"></a>00368 <span class="keyword">template</span> &lt;<span class="keyword">class</span> MATRIX&gt;
<a name="l00369"></a>00369 <span class="keyword">static</span> MATRIX sqrt(<span class="keyword">const</span> MATRIX &amp;matrix)
<a name="l00370"></a>00370 {
<a name="l00371"></a>00371     MATRIX ret(matrix.numRows());
<a name="l00372"></a>00372     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> row = 0; row &lt; matrix.numRows(); ++row) {
<a name="l00373"></a>00373         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> col = 0; col &lt; matrix.numCols(); ++col) {
<a name="l00374"></a>00374             ret[row][col] = sqrt(matrix[row][col]);
<a name="l00375"></a>00375         }
<a name="l00376"></a>00376     }
<a name="l00377"></a>00377     <span class="keywordflow">return</span> ret;
<a name="l00378"></a>00378 }
<a name="l00379"></a>00379 
<a name="l00380"></a>00380 <span class="keyword">template</span> &lt;<span class="keyword">class</span> VECTOR&gt;
<a name="l00381"></a>00381 <span class="keyword">static</span> VECTOR sqrtVector(<span class="keyword">const</span> VECTOR &amp;vec)
<a name="l00382"></a>00382 {
<a name="l00383"></a>00383     VECTOR ret(vec.size());
<a name="l00384"></a>00384     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; vec.size(); ++i) {
<a name="l00385"></a>00385         ret[i] = sqrt(vec[i]);
<a name="l00386"></a>00386     }
<a name="l00387"></a>00387     <span class="keywordflow">return</span> ret;
<a name="l00388"></a>00388 }
<a name="l00389"></a>00389 
<a name="l00390"></a>00390 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">double</span> calculateBestPriorFit(<span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1FixedMatrix.html">Matrix2x2</a> &amp;B, <span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1Priors.html">Priors</a> &amp;priors, <span class="keywordtype">size_t</span> otherprior, <span class="keywordtype">size_t</span> bestpriormatch)
<a name="l00391"></a>00391 {
<a name="l00392"></a>00392     <a class="code" href="classbirdseed_1_1dev_1_1FixedVector.html">FixedVector&lt;double, NUM_ALLELES&gt;</a> priorMeanDelta = priors.getPrior(otherprior).m_mean - priors.getPrior(bestpriormatch).m_mean;
<a name="l00393"></a>00393     <span class="keywordflow">return</span> exp(-((priorMeanDelta * B * priorMeanDelta)/2.0));
<a name="l00394"></a>00394 }
<a name="l00395"></a>00395 
<a name="l00396"></a>00396 <span class="comment">// Returns the index of the prior that the cluster matched</span>
<a name="l00397"></a>00397 <span class="keyword">static</span> <span class="keywordtype">size_t</span> monomorphicCluster(<a class="code" href="classbirdseed_1_1dev_1_1Clusters.html">Clusters</a> *ret,
<a name="l00398"></a>00398                                  <span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1VarMatrix.html">IntensityMatrix</a> &amp;intensities,
<a name="l00399"></a>00399                                  <span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1Priors.html">Priors</a> &amp;priors,
<a name="l00400"></a>00400                                  <span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1FixedVector.html">FixedVector&lt;double, NUM_ALLELES&gt;</a> &amp;stdInterceptPrior)
<a name="l00401"></a>00401 {
<a name="l00402"></a>00402     <span class="keywordtype">int</span> numSamples = intensities.numRows();
<a name="l00403"></a>00403 
<a name="l00404"></a>00404     <span class="comment">// number of gaussians</span>
<a name="l00405"></a>00405     <span class="keywordtype">size_t</span> k = 1;
<a name="l00406"></a>00406     
<a name="l00407"></a>00407     <a class="code" href="classbirdseed_1_1dev_1_1FixedVector.html">FixedVector&lt;double, NUM_ALLELES&gt;</a> means;
<a name="l00408"></a>00408     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; NUM_ALLELES; ++i) {
<a name="l00409"></a>00409         means[i] = mean(intensities, i);
<a name="l00410"></a>00410     }
<a name="l00411"></a>00411 
<a name="l00412"></a>00412     <span class="comment">// check out concordance with the priors:</span>
<a name="l00413"></a>00413     <span class="keywordtype">size_t</span> priorIndexA = Priors::AA_INDEX;
<a name="l00414"></a>00414     <span class="keywordtype">size_t</span> priorIndexB = Priors::BB_INDEX;
<a name="l00415"></a>00415     <span class="keywordflow">if</span> (!priors.isDiploid()) {
<a name="l00416"></a>00416         priorIndexA = Priors::A_INDEX;
<a name="l00417"></a>00417         priorIndexB = Priors::B_INDEX;
<a name="l00418"></a>00418         
<a name="l00419"></a>00419     }
<a name="l00420"></a>00420 
<a name="l00421"></a>00421      <span class="keywordtype">double</span> delta_meanA = priors.getPrior(priorIndexA).m_mean[A_ALLELE_INDEX] - means[A_ALLELE_INDEX];
<a name="l00422"></a>00422      <span class="keywordtype">double</span> delta_meanB = priors.getPrior(priorIndexA).m_mean[B_ALLELE_INDEX] - means[B_ALLELE_INDEX];
<a name="l00423"></a>00423      <span class="keywordtype">double</span> aa_distance_sqrd = (delta_meanA * delta_meanA) + (delta_meanB * delta_meanB);
<a name="l00424"></a>00424      delta_meanA = priors.getPrior(priorIndexB).m_mean[A_ALLELE_INDEX] - means[A_ALLELE_INDEX];
<a name="l00425"></a>00425      delta_meanB = priors.getPrior(priorIndexB).m_mean[B_ALLELE_INDEX] - means[B_ALLELE_INDEX];
<a name="l00426"></a>00426      <span class="keywordtype">double</span> bb_distance_sqrd = (delta_meanA * delta_meanA) + (delta_meanB * delta_meanB);
<a name="l00427"></a>00427      delta_meanA = priors.getPrior(Priors::AB_INDEX).m_mean[A_ALLELE_INDEX] - means[A_ALLELE_INDEX];
<a name="l00428"></a>00428      delta_meanB = priors.getPrior(Priors::AB_INDEX).m_mean[B_ALLELE_INDEX] - means[B_ALLELE_INDEX];
<a name="l00429"></a>00429      <span class="keywordtype">double</span> ab_distance_sqrd = (delta_meanA * delta_meanA) + (delta_meanB * delta_meanB);
<a name="l00430"></a>00430     <span class="keywordtype">size_t</span> bestpriormatch;
<a name="l00431"></a>00431     <span class="keywordtype">size_t</span> otherprior;
<a name="l00432"></a>00432     <span class="keywordflow">if</span> (priors.isDiploid()) {
<a name="l00433"></a>00433         bestpriormatch = (aa_distance_sqrd &lt;= bb_distance_sqrd? Priors::AA_INDEX: Priors::BB_INDEX);
<a name="l00434"></a>00434         <span class="keywordtype">double</span> bestdistance_sqrd = (aa_distance_sqrd &lt;= bb_distance_sqrd? aa_distance_sqrd: bb_distance_sqrd);
<a name="l00435"></a>00435         otherprior = Priors::AB_INDEX;
<a name="l00436"></a>00436         <span class="keywordflow">if</span> (allow_unlikely_clusters) {
<a name="l00437"></a>00437             ab_distance_sqrd *= mono_het_penalty;
<a name="l00438"></a>00438             <span class="keywordflow">if</span> (ab_distance_sqrd &lt; bestdistance_sqrd) {
<a name="l00439"></a>00439                 bestpriormatch = Priors::AB_INDEX;
<a name="l00440"></a>00440             }
<a name="l00441"></a>00441         }
<a name="l00442"></a>00442     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (aa_distance_sqrd &lt;= bb_distance_sqrd) {
<a name="l00443"></a>00443         bestpriormatch = Priors::A_INDEX;
<a name="l00444"></a>00444         otherprior = Priors::B_INDEX;
<a name="l00445"></a>00445     } <span class="keywordflow">else</span> {
<a name="l00446"></a>00446         bestpriormatch = Priors::B_INDEX;
<a name="l00447"></a>00447         otherprior = Priors::A_INDEX;
<a name="l00448"></a>00448     }
<a name="l00449"></a>00449 
<a name="l00450"></a>00450     <span class="comment">// Found best match</span>
<a name="l00451"></a>00451         <span class="keywordflow">if</span> (verbosity&gt;2)
<a name="l00452"></a>00452         {
<a name="l00453"></a>00453                 cout &lt;&lt; <span class="stringliteral">&quot;MonomorphicClusterDistances:\t&quot;</span>;
<a name="l00454"></a>00454                 cout &lt;&lt; aa_distance_sqrd &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00455"></a>00455                 cout &lt;&lt; ab_distance_sqrd &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00456"></a>00456                 cout &lt;&lt; bb_distance_sqrd &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00457"></a>00457                 cout &lt;&lt; endl;
<a name="l00458"></a>00458                 cout &lt;&lt; <span class="stringliteral">&quot;MonomorphicPriorMatch:\t&quot;</span>;
<a name="l00459"></a>00459                 cout &lt;&lt; bestpriormatch &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00460"></a>00460                 cout &lt;&lt; endl;
<a name="l00461"></a>00461         }
<a name="l00462"></a>00462             
<a name="l00463"></a>00463     <span class="keywordtype">double</span> vars[NUM_ALLELES];
<a name="l00464"></a>00464     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; NUM_ALLELES; ++i) {
<a name="l00465"></a>00465         vars[i] = numSamples/(numSamples) * variance(intensities, means[i], i);
<a name="l00466"></a>00466     }
<a name="l00467"></a>00467     <a class="code" href="classbirdseed_1_1dev_1_1FixedMatrix.html">Matrix2x2</a> temp = covariance(intensities, means);
<a name="l00468"></a>00468     <span class="keywordtype">double</span> covar2 = temp[0][1]/sqrt(temp[0][0]*temp[1][1]);
<a name="l00469"></a>00469     <span class="keywordtype">double</span> covar = min(max_covar2, max(covar2, min_covar));
<a name="l00470"></a>00470     <a class="code" href="classbirdseed_1_1dev_1_1FixedMatrix.html">Matrix2x2</a> varmat;
<a name="l00471"></a>00471     varmat[0][0] = vars[0];
<a name="l00472"></a>00472     varmat[1][0] = varmat[0][1] = covar * sqrt(vars[0]*vars[1]);
<a name="l00473"></a>00473     varmat[1][1] = vars[1];
<a name="l00474"></a>00474     <a class="code" href="classbirdseed_1_1dev_1_1FixedMatrix.html">Matrix2x2</a> B = invert(varmat);
<a name="l00475"></a>00475     <span class="keywordtype">double</span> bestpriorfit;
<a name="l00476"></a>00476     <span class="keywordflow">if</span> (priors.isDiploid() &amp;&amp; bestpriormatch == Priors::AB_INDEX) {
<a name="l00477"></a>00477         bestpriorfit = max(calculateBestPriorFit(B, priors, Priors::AA_INDEX, Priors::AB_INDEX),
<a name="l00478"></a>00478                            calculateBestPriorFit(B, priors, Priors::BB_INDEX, Priors::AB_INDEX));
<a name="l00479"></a>00479     } <span class="keywordflow">else</span> {
<a name="l00480"></a>00480         bestpriorfit = calculateBestPriorFit(B, priors, otherprior, bestpriormatch);
<a name="l00481"></a>00481     }
<a name="l00482"></a>00482 
<a name="l00483"></a>00483     <span class="keywordtype">double</span> A = (1/sqrt(determinant(varmat)))/(2*pi);
<a name="l00484"></a>00484     <span class="keywordtype">double</span> sum_log_pxi_zj = 0.0;
<a name="l00485"></a>00485     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numSamples; ++i) {
<a name="l00486"></a>00486         sum_log_pxi_zj += log(A * exp(-((intensities[i] - means) * B * (intensities[i] - means))/2.0));
<a name="l00487"></a>00487     }
<a name="l00488"></a>00488 
<a name="l00489"></a>00489     <span class="comment">// fill in the missing gaussians</span>
<a name="l00490"></a>00490     <a class="code" href="classbirdseed_1_1dev_1_1FixedVector.html">FixedVector&lt;double, NUM_ALLELES&gt;</a> stdIntercept;
<a name="l00491"></a>00491     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> d = 0; d &lt; NUM_ALLELES; ++d) {
<a name="l00492"></a>00492         stdIntercept[d] = sqrt(vars[d]) - std_slope*means[d];
<a name="l00493"></a>00493     }
<a name="l00494"></a>00494 
<a name="l00495"></a>00495         <span class="keywordtype">double</span> expMeans[3][2];
<a name="l00496"></a>00496         <span class="keywordflow">if</span>(bestpriormatch==0){
<a name="l00497"></a>00497           expMeans[0][0] = means[0];
<a name="l00498"></a>00498           expMeans[0][1] = means[1];
<a name="l00499"></a>00499           expMeans[1][0] = means[0]*0.634 + means[1]*0.180;
<a name="l00500"></a>00500           expMeans[1][1] = means[0]*0.389 + means[1]*1.011;
<a name="l00501"></a>00501           expMeans[2][0] = means[0]*0.140 + means[1]*0.506;
<a name="l00502"></a>00502           expMeans[2][1] = means[0]*0.679 + means[1]*1.077;
<a name="l00503"></a>00503         } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(bestpriormatch==2){
<a name="l00504"></a>00504           expMeans[0][0] = means[0]*1.008 + means[1]*0.684;
<a name="l00505"></a>00505           expMeans[0][1] = means[0]*0.470 + means[1]*0.131;       
<a name="l00506"></a>00506           expMeans[1][0] = means[0]*0.972 + means[1]*0.392;
<a name="l00507"></a>00507           expMeans[1][1] = means[0]*0.167 + means[1]*0.630;
<a name="l00508"></a>00508           expMeans[2][0] = means[0];
<a name="l00509"></a>00509           expMeans[2][1] = means[1];
<a name="l00510"></a>00510         } <span class="keywordflow">else</span> { <span class="comment">//bestpriormatch is the het cluster</span>
<a name="l00511"></a>00511           expMeans[0][0] = means[0]*1.489 + means[1]*(0-0.027);
<a name="l00512"></a>00512           expMeans[0][1] = means[0]*0.075 + means[1]*0.316;       
<a name="l00513"></a>00513           expMeans[1][0] = means[0];
<a name="l00514"></a>00514           expMeans[1][1] = means[1];
<a name="l00515"></a>00515           expMeans[2][0] = means[0]*0.310 + means[1]*0.098;
<a name="l00516"></a>00516           expMeans[2][1] = means[0]*(0-0.010) + means[1]*1.483;
<a name="l00517"></a>00517         }
<a name="l00518"></a>00518         
<a name="l00519"></a>00519         ret-&gt;means.resize(priors.getNumPriors());
<a name="l00520"></a>00520     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; priors.getNumPriors(); ++i) {
<a name="l00521"></a>00521           <span class="keywordflow">if</span> (i==bestpriormatch){
<a name="l00522"></a>00522                 ret-&gt;means[i][0] = ((expMeans[i][0] * numSamples) + (priors.getPrior(i).m_mean[0] * anchor_weight)) / (numSamples + anchor_weight);
<a name="l00523"></a>00523                 ret-&gt;means[i][1] = ((expMeans[i][1] * numSamples) + (priors.getPrior(i).m_mean[1] * anchor_weight)) / (numSamples + anchor_weight);
<a name="l00524"></a>00524           } <span class="keywordflow">else</span> {
<a name="l00525"></a>00525                 ret-&gt;means[i][0] = (expMeans[i][0] + (priors.getPrior(i).m_mean[0]* max_anchor_percentage)) / (1+max_anchor_percentage);
<a name="l00526"></a>00526                 ret-&gt;means[i][1] = (expMeans[i][1] + (priors.getPrior(i).m_mean[1]* max_anchor_percentage)) / (1+max_anchor_percentage);
<a name="l00527"></a>00527           }
<a name="l00528"></a>00528     }
<a name="l00529"></a>00529 
<a name="l00530"></a>00530     <span class="keywordtype">double</span> var_mult_sq = var_mult * var_mult;
<a name="l00531"></a>00531     ret-&gt;vars.resize(priors.getNumPriors());
<a name="l00532"></a>00532     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> row = 0; row &lt; priors.getNumPriors(); ++row) {
<a name="l00533"></a>00533         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> col = 0; col &lt; NUM_ALLELES; ++col) {
<a name="l00534"></a>00534           ret-&gt;vars[row][col] = 
<a name="l00535"></a>00535             (stdIntercept[col] + std_slope*ret-&gt;means[row][col]) * 
<a name="l00536"></a>00536             (stdIntercept[col] + std_slope*ret-&gt;means[row][col]);
<a name="l00537"></a>00537 
<a name="l00538"></a>00538             <span class="keywordflow">if</span> (row != bestpriormatch) {
<a name="l00539"></a>00539                 ret-&gt;vars[row][col] *= var_mult_sq;
<a name="l00540"></a>00540             }
<a name="l00541"></a>00541         }
<a name="l00542"></a>00542     }
<a name="l00543"></a>00543     ret-&gt;weights.resize(priors.getNumPriors());
<a name="l00544"></a>00544     ret-&gt;weights.setAllElements(starting_cluster_weight);
<a name="l00545"></a>00545     <span class="keywordflow">if</span> (priors.getNumPriors() == MAX_NUM_CLUSTERS) {
<a name="l00546"></a>00546         ret-&gt;weights[bestpriormatch] = 1-2*starting_cluster_weight;
<a name="l00547"></a>00547     } <span class="keywordflow">else</span> {
<a name="l00548"></a>00548         ret-&gt;weights[bestpriormatch] = 1-starting_cluster_weight;
<a name="l00549"></a>00549     }
<a name="l00550"></a>00550 
<a name="l00551"></a>00551         <span class="keywordflow">if</span> (verbosity&gt;2)
<a name="l00552"></a>00552         {
<a name="l00553"></a>00553                 cout &lt;&lt; <span class="stringliteral">&quot;MonomorphicClusterLogL:\t&quot;</span>;
<a name="l00554"></a>00554                 cout &lt;&lt; sum_log_pxi_zj &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00555"></a>00555                 cout &lt;&lt; max(0.0,low_covar_threshold-covar2) &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00556"></a>00556                 cout &lt;&lt; bestpriorfit &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00557"></a>00557                 cout &lt;&lt; 0.5*(2*k+2+k)*log(static_cast&lt;double&gt;(numSamples)) &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00558"></a>00558                 cout &lt;&lt; endl;
<a name="l00559"></a>00559         }
<a name="l00560"></a>00560     ret-&gt;log_likelihood = sum_log_pxi_zj
<a name="l00561"></a>00561         - low_covar_penalty*log(static_cast&lt;double&gt;(numSamples))*max(0.0, low_covar_threshold-covar2)
<a name="l00562"></a>00562         - wing_length_delta_penalty*bestpriorfit
<a name="l00563"></a>00563         - bic_weight*0.5*(2*k+2+k)*log(static_cast&lt;double&gt;(numSamples));
<a name="l00564"></a>00564     ret-&gt;covar = covar;
<a name="l00565"></a>00565 
<a name="l00566"></a>00566     <span class="keywordflow">return</span> bestpriormatch;
<a name="l00567"></a>00567 }
<a name="l00568"></a>00568 
<a name="l00569"></a>00569 
<a name="l00570"></a>00570 <span class="keyword">static</span> <span class="keywordtype">void</span> initialize(<a class="code" href="classbirdseed_1_1dev_1_1Clusters.html">Clusters</a> *ret,
<a name="l00571"></a>00571                        <span class="keywordtype">size_t</span> k,
<a name="l00572"></a>00572                        <span class="keywordtype">size_t</span> count,
<a name="l00573"></a>00573                        <span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1VarMatrix.html">IntensityMatrix</a> &amp;intensities,
<a name="l00574"></a>00574                        <span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1Priors.html">Priors</a> &amp;priors,
<a name="l00575"></a>00575                        <span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1FixedVector.html">FixedVector&lt;double, NUM_ALLELES&gt;</a> &amp;stdInterceptPrior,
<a name="l00576"></a>00576                        <span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1VarMatrixWithReservedRows.html">VarMatrixWithReservedRows&lt;double, MAX_NUM_CLUSTERS, NUM_ALLELES&gt;</a> &amp;oldavgvars,
<a name="l00577"></a>00577                        <span class="keywordtype">size_t</span> bestpriormatch)
<a name="l00578"></a>00578 {
<a name="l00579"></a>00579 
<a name="l00580"></a>00580     assert(k &gt; 1);
<a name="l00581"></a>00581     <span class="keywordflow">if</span> (k == 2) {
<a name="l00582"></a>00582         ret-&gt;covar = 0;
<a name="l00583"></a>00583         ret-&gt;weights.resize(k);
<a name="l00584"></a>00584         ret-&gt;weights.setAllElements(1.0/k);
<a name="l00585"></a>00585         ret-&gt;means.resize(2);
<a name="l00586"></a>00586         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> col = 0; col &lt; NUM_ALLELES; ++col) {
<a name="l00587"></a>00587             ret-&gt;means[0][col] = priors.getAPrior().m_mean[col];
<a name="l00588"></a>00588             ret-&gt;means[1][col] = priors.getBPrior().m_mean[col];
<a name="l00589"></a>00589         }
<a name="l00590"></a>00590         <a class="code" href="classbirdseed_1_1dev_1_1FixedMatrix.html">Matrix2x2</a> temp;
<a name="l00591"></a>00591         temp[0][0] = temp[1][0] = stdInterceptPrior[0];
<a name="l00592"></a>00592         temp[0][1] = temp[1][1] = stdInterceptPrior[1];
<a name="l00593"></a>00593 
<a name="l00594"></a>00594         ret-&gt;vars.resize(2);
<a name="l00595"></a>00595         ret-&gt;vars = pow(temp + ret-&gt;means * std_slope, 2) * var_start;
<a name="l00596"></a>00596         <span class="keywordflow">if</span> (special &amp;&amp; count == 1) {
<a name="l00597"></a>00597             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> row = 0; row &lt; k; ++row) {
<a name="l00598"></a>00598                 <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> col = 0; col &lt; NUM_ALLELES; ++col) {
<a name="l00599"></a>00599                     ret-&gt;vars[row][col] =
<a name="l00600"></a>00600                         0.666 * oldavgvars[bestpriormatch][col];
<a name="l00601"></a>00601                 }
<a name="l00602"></a>00602             }
<a name="l00603"></a>00603         }
<a name="l00604"></a>00604     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (k == 3) {
<a name="l00605"></a>00605         ret-&gt;weights.resize(k);
<a name="l00606"></a>00606         ret-&gt;weights.setAllElements(1.0/k);
<a name="l00607"></a>00607         <span class="keywordflow">if</span> (special &amp;&amp; count == 2) {
<a name="l00608"></a>00608             ret-&gt;means.resize(3);
<a name="l00609"></a>00609             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> row = 0; row &lt; MAX_NUM_CLUSTERS; ++row) {
<a name="l00610"></a>00610                 ret-&gt;means[row] = priors.getPrior(row).m_mean;
<a name="l00611"></a>00611             }
<a name="l00612"></a>00612             ret-&gt;vars.resize(3);
<a name="l00613"></a>00613             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> row = 0; row &lt; MAX_NUM_CLUSTERS; ++row) {
<a name="l00614"></a>00614                 ret-&gt;vars[row][0] = priors.getPrior(row).m_covarMatrix[0][0];
<a name="l00615"></a>00615                 ret-&gt;vars[row][1] = priors.getPrior(row).m_covarMatrix[1][1];
<a name="l00616"></a>00616             }
<a name="l00617"></a>00617             <span class="keywordtype">double</span> acc = 0;
<a name="l00618"></a>00618             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; MAX_NUM_CLUSTERS; ++i) {
<a name="l00619"></a>00619                 acc += priors.getPrior(i).m_numObservations * priors.getPrior(i).m_covarMatrix[1][0] /
<a name="l00620"></a>00620                     sqrt(priors.getPrior(i).m_covarMatrix[0][0] * priors.getPrior(i).m_covarMatrix[1][1]);
<a name="l00621"></a>00621             }
<a name="l00622"></a>00622             ret-&gt;covar = max(min_covar,min(max_covar1, acc/priors.numObservations()));
<a name="l00623"></a>00623         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (special) {
<a name="l00624"></a>00624             ret-&gt;means.resize(3);
<a name="l00625"></a>00625             ret-&gt;means[0][0] = minInColumn(intensities, 0);
<a name="l00626"></a>00626             ret-&gt;means[0][1] = maxInColumn(intensities, 1);
<a name="l00627"></a>00627             ret-&gt;means[2][0] = maxInColumn(intensities, 0);
<a name="l00628"></a>00628             ret-&gt;means[2][1] = minInColumn(intensities, 1);
<a name="l00629"></a>00629             ret-&gt;means[1] = (ret-&gt;means[0] + ret-&gt;means[2])/2;
<a name="l00630"></a>00630 
<a name="l00631"></a>00631             ret-&gt;vars.resize(3);
<a name="l00632"></a>00632             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> row = 0; row &lt; ret-&gt;means.numRows(); ++row) {
<a name="l00633"></a>00633                 <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> col = 0; col &lt; ret-&gt;means.numCols(); ++col) {
<a name="l00634"></a>00634                   ret-&gt;vars[row][col] = 
<a name="l00635"></a>00635                       ((ret-&gt;means[row][col] * std_slope + stdInterceptPrior[col]) * 
<a name="l00636"></a>00636                        (ret-&gt;means[row][col] * std_slope + stdInterceptPrior[col])) * 
<a name="l00637"></a>00637                     var_start;
<a name="l00638"></a>00638                 }
<a name="l00639"></a>00639             }
<a name="l00640"></a>00640             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> col = 0; col &lt; ret-&gt;vars.numCols(); ++col) {
<a name="l00641"></a>00641                 ret-&gt;vars[1][col] /= 20;
<a name="l00642"></a>00642             }
<a name="l00643"></a>00643             ret-&gt;covar = 0.0;
<a name="l00644"></a>00644         } <span class="keywordflow">else</span> {
<a name="l00645"></a>00645             ret-&gt;means.resize(3);
<a name="l00646"></a>00646             ret-&gt;vars.resize(3);
<a name="l00647"></a>00647             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> row = 0; row &lt; MAX_NUM_CLUSTERS; ++row) {
<a name="l00648"></a>00648                 ret-&gt;means[row] = priors.getPrior(row).m_mean;
<a name="l00649"></a>00649                 ret-&gt;vars[row][0] = priors.getPrior(row).m_covarMatrix[0][0];
<a name="l00650"></a>00650                 ret-&gt;vars[row][1] = priors.getPrior(row).m_covarMatrix[1][1];
<a name="l00651"></a>00651             }
<a name="l00652"></a>00652             ret-&gt;covar = 0.0;
<a name="l00653"></a>00653         }
<a name="l00654"></a>00654     } <span class="keywordflow">else</span> {
<a name="l00655"></a>00655         assert(<span class="keyword">false</span>);
<a name="l00656"></a>00656     }
<a name="l00657"></a>00657 }
<a name="l00658"></a>00658 
<a name="l00659"></a>00659 <span class="comment">// k=2 case</span>
<a name="l00660"></a>00660 <span class="comment">// Not called for male chrX </span>
<a name="l00661"></a>00661 <span class="keyword">static</span> <span class="keywordtype">void</span> fillInMissingGaussians(<a class="code" href="classbirdseed_1_1dev_1_1Clusters.html">Clusters</a> *clusters, <span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1Priors.html">Priors</a> &amp;priors, <span class="keywordtype">size_t</span> numSamples)
<a name="l00662"></a>00662 {
<a name="l00663"></a>00663     <span class="comment">// fill in missing Gaussians:</span>
<a name="l00664"></a>00664     <span class="comment">// check out concordance with the priors:</span>
<a name="l00665"></a>00665     <span class="comment">// If all else fails, consider clusters to be AA and AB</span>
<a name="l00666"></a>00666     <span class="keywordtype">size_t</span> bestpriormatch[2] = {0, 1};
<a name="l00667"></a>00667     <span class="keywordtype">double</span> bestdistance = INFINITY;
<a name="l00668"></a>00668     <span class="keywordtype">double</span> bestshift1 = 0;
<a name="l00669"></a>00669     <span class="keywordtype">double</span> bestshift2 = 0;
<a name="l00670"></a>00670     <span class="keywordtype">double</span> bestscale1 = 1;
<a name="l00671"></a>00671     <span class="keywordtype">double</span> bestscale2 = 1;
<a name="l00672"></a>00672 
<a name="l00673"></a>00673     <span class="comment">// Just syntactic sugar</span>
<a name="l00674"></a>00674     <a class="code" href="classbirdseed_1_1dev_1_1VarMatrixWithReservedRows.html">VarMatrixWithReservedRows&lt;double, MAX_NUM_CLUSTERS, NUM_ALLELES&gt;</a> &amp;means = clusters-&gt;means;
<a name="l00675"></a>00675     
<a name="l00676"></a>00676     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> firstCluster = Priors::AA_INDEX; firstCluster &lt; Priors::BB_INDEX; ++firstCluster) {
<a name="l00677"></a>00677         <span class="keywordtype">size_t</span> maxSecondCluster;
<a name="l00678"></a>00678         maxSecondCluster = (allow_unlikely_clusters? Priors::BB_INDEX: firstCluster + 1);
<a name="l00679"></a>00679         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> secondCluster = firstCluster + 1; secondCluster &lt;= maxSecondCluster; ++secondCluster) {
<a name="l00680"></a>00680 
<a name="l00681"></a>00681             <span class="comment">// Hom cluster should not have low weight</span>
<a name="l00682"></a>00682                 <span class="keywordflow">if</span> (verbosity&gt;2)
<a name="l00683"></a>00683                 {
<a name="l00684"></a>00684                         cout &lt;&lt; <span class="stringliteral">&quot;2fillCluster:\t&quot;</span>;
<a name="l00685"></a>00685                         cout &lt;&lt; firstCluster &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00686"></a>00686                         cout &lt;&lt; clusters-&gt;weights[0] &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00687"></a>00687                         cout &lt;&lt; low_hom_weight_fraction*(numSamples/(numSamples+low_hom_sample_inflation)) &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00688"></a>00688                         cout &lt;&lt; secondCluster &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00689"></a>00689                         cout &lt;&lt; clusters-&gt;weights[1] &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00690"></a>00690                         cout &lt;&lt; endl;
<a name="l00691"></a>00691                 }
<a name="l00692"></a>00692             <span class="keywordflow">if</span> (firstCluster == Priors::AA_INDEX &amp;&amp; clusters-&gt;weights[0] &lt; low_hom_weight_fraction*numSamples/(numSamples+low_hom_sample_inflation)) {
<a name="l00693"></a>00693                 <span class="keywordflow">continue</span>;
<a name="l00694"></a>00694             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (secondCluster == Priors::BB_INDEX &amp;&amp; clusters-&gt;weights[1] &lt; low_hom_weight_fraction*numSamples/(numSamples+low_hom_sample_inflation)) {
<a name="l00695"></a>00695                 <span class="keywordflow">continue</span>;
<a name="l00696"></a>00696             }
<a name="l00697"></a>00697         
<a name="l00698"></a>00698             <a class="code" href="classbirdseed_1_1dev_1_1FixedMatrix.html">Matrix2x2</a> tempmat;
<a name="l00699"></a>00699             tempmat[0][1] = tempmat[1][1] = 1;
<a name="l00700"></a>00700             tempmat[0][0] = priors.getPrior(firstCluster).m_mean[0];
<a name="l00701"></a>00701             tempmat[1][0] = priors.getPrior(secondCluster).m_mean[0];
<a name="l00702"></a>00702 
<a name="l00703"></a>00703             <a class="code" href="classbirdseed_1_1dev_1_1FixedVector.html">FixedVector&lt;double, 2&gt;</a> temp1 = invert(tempmat) * means.columnSlice(0);
<a name="l00704"></a>00704 
<a name="l00705"></a>00705             tempmat[0][1] = tempmat[1][1] = 1;
<a name="l00706"></a>00706             tempmat[0][0] = priors.getPrior(firstCluster).m_mean[1];
<a name="l00707"></a>00707             tempmat[1][0] = priors.getPrior(secondCluster).m_mean[1];
<a name="l00708"></a>00708                         
<a name="l00709"></a>00709             <a class="code" href="classbirdseed_1_1dev_1_1FixedVector.html">FixedVector&lt;double, 2&gt;</a> temp2 = invert(tempmat) * means.columnSlice(1);
<a name="l00710"></a>00710 
<a name="l00711"></a>00711             <a class="code" href="classbirdseed_1_1dev_1_1FixedVector.html">FixedVector&lt;double, 2&gt;</a> priorMeanSlice0;
<a name="l00712"></a>00712             priorMeanSlice0[0] = priors.getPrior(firstCluster).m_mean[0];
<a name="l00713"></a>00713             priorMeanSlice0[1] = priors.getPrior(secondCluster).m_mean[0];
<a name="l00714"></a>00714 
<a name="l00715"></a>00715             <a class="code" href="classbirdseed_1_1dev_1_1FixedVector.html">FixedVector&lt;double, 2&gt;</a> priorMeanSlice1;
<a name="l00716"></a>00716             priorMeanSlice1[0] = priors.getPrior(firstCluster).m_mean[1];
<a name="l00717"></a>00717             priorMeanSlice1[1] = priors.getPrior(secondCluster).m_mean[1];
<a name="l00718"></a>00718                         
<a name="l00719"></a>00719             <span class="keywordtype">double</span> distance = meanVector(sqrtVector(powVector(priorMeanSlice0 - means.columnSlice(0), 2) +
<a name="l00720"></a>00720                                                     powVector(priorMeanSlice1 - means.columnSlice(1), 2)));
<a name="l00721"></a>00721 
<a name="l00722"></a>00722             <span class="comment">// Penalize this alignment if the hom cluster has few observations</span>
<a name="l00723"></a>00723             <span class="keywordflow">if</span> (firstCluster == Priors::AA_INDEX &amp;&amp; priors.getPrior(Priors::AA_INDEX).m_numObservations &lt; priors.numObservations()) {
<a name="l00724"></a>00724                 distance *= sqrt((two_cluster_low_observation_penalty_factor + priors.numObservations())/(two_cluster_low_observation_penalty_factor + priors.getPrior(Priors::AA_INDEX).m_numObservations));
<a name="l00725"></a>00725             }
<a name="l00726"></a>00726             <span class="comment">// There is potentially a double penalty if for the AA-BB alignment, if both have few observations.</span>
<a name="l00727"></a>00727             <span class="keywordflow">if</span> (secondCluster == Priors::BB_INDEX &amp;&amp; priors.getPrior(Priors::BB_INDEX).m_numObservations &lt; priors.numObservations()) {
<a name="l00728"></a>00728                 distance *= sqrt((two_cluster_low_observation_penalty_factor + priors.numObservations())/(two_cluster_low_observation_penalty_factor + priors.getPrior(Priors::BB_INDEX).m_numObservations));
<a name="l00729"></a>00729             }
<a name="l00730"></a>00730             <span class="keywordflow">if</span> (firstCluster == Priors::AA_INDEX &amp;&amp; secondCluster == Priors::BB_INDEX) {
<a name="l00731"></a>00731                 distance *= hom_hom_penalty;
<a name="l00732"></a>00732             }
<a name="l00733"></a>00733                 <span class="keywordflow">if</span> (verbosity&gt;2)
<a name="l00734"></a>00734                 {
<a name="l00735"></a>00735                         <span class="comment">// decision made on distance</span>
<a name="l00736"></a>00736                         cout &lt;&lt; <span class="stringliteral">&quot;2fillClusterDistance:\t&quot;</span>;
<a name="l00737"></a>00737                         cout &lt;&lt; distance &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00738"></a>00738                         cout &lt;&lt; temp1[0] &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; temp2[0] &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00739"></a>00739                         cout &lt;&lt; temp1[1] &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; temp2[1] &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00740"></a>00740                         cout &lt;&lt; endl;
<a name="l00741"></a>00741                 }
<a name="l00742"></a>00742             <span class="keywordflow">if</span> (distance&lt;bestdistance) {
<a name="l00743"></a>00743                 bestdistance = distance;
<a name="l00744"></a>00744                 bestpriormatch[0] = firstCluster;
<a name="l00745"></a>00745                 bestpriormatch[1] = secondCluster;
<a name="l00746"></a>00746                 bestscale1 = temp1[0];
<a name="l00747"></a>00747                 bestscale2 = temp2[0];
<a name="l00748"></a>00748                 bestshift1 = temp1[1];
<a name="l00749"></a>00749                 bestshift2 = temp2[1];
<a name="l00750"></a>00750             }
<a name="l00751"></a>00751         }
<a name="l00752"></a>00752     }
<a name="l00753"></a>00753     
<a name="l00754"></a>00754     <a class="code" href="classbirdseed_1_1dev_1_1VarMatrixWithReservedRows.html">VarMatrixWithReservedRows&lt;double, MAX_NUM_CLUSTERS, NUM_ALLELES&gt;</a> oldMeans(clusters-&gt;means);
<a name="l00755"></a>00755     <a class="code" href="classbirdseed_1_1dev_1_1VarMatrixWithReservedRows.html">VarMatrixWithReservedRows&lt;double, MAX_NUM_CLUSTERS, NUM_ALLELES&gt;</a> oldVars(clusters-&gt;vars);
<a name="l00756"></a>00756     <a class="code" href="classbirdseed_1_1dev_1_1VarVectorWithReservedLength.html">VarVectorWithReservedLength&lt;double, MAX_NUM_CLUSTERS&gt;</a> oldWeights(clusters-&gt;weights);
<a name="l00757"></a>00757     <span class="comment">// fill in the missing gaussians:</span>
<a name="l00758"></a>00758     <a class="code" href="classbirdseed_1_1dev_1_1FixedVector.html">FixedVector&lt;double, NUM_ALLELES&gt;</a> stdIntercept;
<a name="l00759"></a>00759     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> d = 0; d &lt; NUM_ALLELES; ++d) {
<a name="l00760"></a>00760         stdIntercept[d] = meanVector(sqrtVector(clusters-&gt;vars.columnSlice(d)) -
<a name="l00761"></a>00761                               clusters-&gt;means.columnSlice(d) * std_slope);
<a name="l00762"></a>00762     }
<a name="l00763"></a>00763 
<a name="l00764"></a>00764     clusters-&gt;means.resize(MAX_NUM_CLUSTERS);
<a name="l00765"></a>00765 
<a name="l00766"></a>00766         <span class="keywordtype">double</span> expMeans[3][2];
<a name="l00767"></a>00767         <span class="keywordflow">if</span>((bestpriormatch[0]==0) &amp;&amp; (bestpriormatch[1]==1)){
<a name="l00768"></a>00768           expMeans[0][0] = means[0][0];
<a name="l00769"></a>00769           expMeans[0][1] = means[0][1];
<a name="l00770"></a>00770           expMeans[1][0] = means[1][0];
<a name="l00771"></a>00771           expMeans[1][1] = means[1][1];
<a name="l00772"></a>00772           expMeans[2][0] = means[0][0]*(0-1.048) + means[0][1]*0.149 + means[1][0]*1.860 + means[1][1]*0.023;
<a name="l00773"></a>00773           expMeans[2][1] = means[0][0]*0.123 + means[0][1]*(0-0.586) + means[1][0]*(0-0.149) + means[1][1]*1.672;
<a name="l00774"></a>00774         } <span class="keywordflow">else</span> <span class="keywordflow">if</span>((bestpriormatch[0]==1) &amp;&amp; (bestpriormatch[1]==2)){
<a name="l00775"></a>00775           expMeans[0][0] = means[0][0]*1.675 + means[0][1]*(0-0.147) + means[1][0]*(0-.596) + means[1][1]*0.120;
<a name="l00776"></a>00776           expMeans[0][1] = means[0][0]*0.020 + means[0][1]*1.831 + means[1][0]*0.143 + means[1][1]*(0-1.031);
<a name="l00777"></a>00777           expMeans[1][0] = means[0][0];
<a name="l00778"></a>00778           expMeans[1][1] = means[0][1];
<a name="l00779"></a>00779           expMeans[2][0] = means[1][0];
<a name="l00780"></a>00780           expMeans[2][1] = means[1][1];
<a name="l00781"></a>00781         } <span class="keywordflow">else</span> { <span class="comment">//bestpriormatch is the hom/hom</span>
<a name="l00782"></a>00782           expMeans[0][0] = means[0][0];
<a name="l00783"></a>00783           expMeans[0][1] = means[0][1];
<a name="l00784"></a>00784           expMeans[1][0] = means[0][0]*0.585 + means[0][1]*(0-0.008) + means[1][0]*0.387 + means[1][1]*(0-0.007);
<a name="l00785"></a>00785           expMeans[1][1] = means[0][0]*(0-0.008) + means[0][1]*0.382 + means[1][0]*(0-0.003) + means[1][1]*0.586;
<a name="l00786"></a>00786           expMeans[2][0] = means[1][0];
<a name="l00787"></a>00787           expMeans[2][1] = means[1][1];
<a name="l00788"></a>00788         }
<a name="l00789"></a>00789         
<a name="l00790"></a>00790     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; priors.getNumPriors(); ++i) {
<a name="l00791"></a>00791           <span class="keywordflow">if</span> (i==bestpriormatch[0]){
<a name="l00792"></a>00792                 clusters-&gt;means[i][0] = ((expMeans[i][0] * oldWeights[0] * numSamples) + (priors.getPrior(i).m_mean[0] * anchor_weight)) / (oldWeights[0] * numSamples + anchor_weight);
<a name="l00793"></a>00793                 clusters-&gt;means[i][1] = ((expMeans[i][1] * oldWeights[0] * numSamples) + (priors.getPrior(i).m_mean[1] * anchor_weight)) / (oldWeights[0] * numSamples + anchor_weight);
<a name="l00794"></a>00794           } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i==bestpriormatch[1]){
<a name="l00795"></a>00795                 clusters-&gt;means[i][0] = ((expMeans[i][0] * oldWeights[1] * numSamples) + (priors.getPrior(i).m_mean[0] * anchor_weight)) / (oldWeights[1] * numSamples + anchor_weight);
<a name="l00796"></a>00796                 clusters-&gt;means[i][1] = ((expMeans[i][1] * oldWeights[1] * numSamples) + (priors.getPrior(i).m_mean[1] * anchor_weight)) / (oldWeights[1] * numSamples + anchor_weight);
<a name="l00797"></a>00797           } <span class="keywordflow">else</span> {
<a name="l00798"></a>00798                 clusters-&gt;means[i][0] = (expMeans[i][0] + (priors.getPrior(i).m_mean[0]* max_anchor_percentage)) / (1+max_anchor_percentage);
<a name="l00799"></a>00799                 clusters-&gt;means[i][1] = (expMeans[i][1] + (priors.getPrior(i).m_mean[1]* max_anchor_percentage)) / (1+max_anchor_percentage);
<a name="l00800"></a>00800           }
<a name="l00801"></a>00801     }
<a name="l00802"></a>00802 
<a name="l00803"></a>00803     <span class="comment">/*Old, no longer in use:</span>
<a name="l00804"></a>00804 <span class="comment">        for (size_t i = 0; i &lt; MAX_NUM_CLUSTERS; ++i) {</span>
<a name="l00805"></a>00805 <span class="comment">          if(i==bestpriormatch[0]) {</span>
<a name="l00806"></a>00806 <span class="comment">        clusters-&gt;means[i][0] = (numSamples * oldWeights[0] * (bestshift1 + priors.getPrior(i).m_mean[0] * bestscale1) + (anchor_weight * priors.getPrior(i).m_mean[0]))/(numSamples * oldWeights[0] + anchor_weight);</span>
<a name="l00807"></a>00807 <span class="comment">        clusters-&gt;means[i][1] = (numSamples * oldWeights[0] * (bestshift2 + priors.getPrior(i).m_mean[1] * bestscale2) + (anchor_weight * priors.getPrior(i).m_mean[1]))/(numSamples * oldWeights[0] + anchor_weight);</span>
<a name="l00808"></a>00808 <span class="comment">          } else if(i==bestpriormatch[1]) {</span>
<a name="l00809"></a>00809 <span class="comment">        clusters-&gt;means[i][0] = (numSamples * oldWeights[1] * (bestshift1 + priors.getPrior(i).m_mean[0] * bestscale1) + (anchor_weight * priors.getPrior(i).m_mean[0]))/(numSamples * oldWeights[1] + anchor_weight);</span>
<a name="l00810"></a>00810 <span class="comment">        clusters-&gt;means[i][1] = (numSamples * oldWeights[1] * (bestshift2 + priors.getPrior(i).m_mean[1] * bestscale2) + (anchor_weight * priors.getPrior(i).m_mean[1]))/(numSamples * oldWeights[1] + anchor_weight);</span>
<a name="l00811"></a>00811 <span class="comment">          } else {</span>
<a name="l00812"></a>00812 <span class="comment">        clusters-&gt;means[i][0] = (bestshift1 + priors.getPrior(i).m_mean[0] * (bestscale1 + max_anchor_percentage))/(1+max_anchor_percentage);</span>
<a name="l00813"></a>00813 <span class="comment">        clusters-&gt;means[i][1] = (bestshift2 + priors.getPrior(i).m_mean[1] * (bestscale2 + max_anchor_percentage))/(1+max_anchor_percentage);</span>
<a name="l00814"></a>00814 <span class="comment">          }</span>
<a name="l00815"></a>00815 <span class="comment">    }</span>
<a name="l00816"></a>00816 <span class="comment">        */</span>
<a name="l00817"></a>00817 
<a name="l00818"></a>00818     <span class="comment">//for (size_t i = 0; i &lt; 2; ++i) {</span>
<a name="l00819"></a>00819     <span class="comment">//    clusters-&gt;means[bestpriormatch[i]] = oldMeans[i];</span>
<a name="l00820"></a>00820     <span class="comment">//}</span>
<a name="l00821"></a>00821     clusters-&gt;means = maxMatrixElementwise(clusters-&gt;means, 50);
<a name="l00822"></a>00822     clusters-&gt;vars.resize(MAX_NUM_CLUSTERS);
<a name="l00823"></a>00823     <span class="keywordtype">double</span> var_mult_sq = var_mult * var_mult;
<a name="l00824"></a>00824     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> row = 0; row &lt; MAX_NUM_CLUSTERS; ++row) {
<a name="l00825"></a>00825         clusters-&gt;vars[row] = powVector(stdIntercept + clusters-&gt;means[row]*std_slope, 2) * var_mult_sq;
<a name="l00826"></a>00826     }
<a name="l00827"></a>00827     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; 2; ++i) {
<a name="l00828"></a>00828         clusters-&gt;vars[bestpriormatch[i]] = oldVars[i];
<a name="l00829"></a>00829     }
<a name="l00830"></a>00830     clusters-&gt;weights.resize(MAX_NUM_CLUSTERS);
<a name="l00831"></a>00831     clusters-&gt;weights.setAllElements(starting_cluster_weight);
<a name="l00832"></a>00832     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; 2; ++i) {
<a name="l00833"></a>00833         clusters-&gt;weights[bestpriormatch[i]] = min(1 - starting_cluster_weight * (MAX_NUM_CLUSTERS-1),
<a name="l00834"></a>00834                                                      max(starting_cluster_weight,
<a name="l00835"></a>00835                                                          oldWeights[i] *
<a name="l00836"></a>00836                                                          (1 - starting_cluster_weight * (MAX_NUM_CLUSTERS-2))));
<a name="l00837"></a>00837     }
<a name="l00838"></a>00838 }
<a name="l00839"></a>00839 
<a name="l00840"></a>00840 <span class="keywordtype">void</span> birdseed::dev::calculatePXI_ZJ(<a class="code" href="classbirdseed_1_1dev_1_1VarVarMatrix.html">PXI_ZJMatrix</a> *pxi_zj,
<a name="l00841"></a>00841                                <span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1Clusters.html">Clusters</a> &amp;clusters,
<a name="l00842"></a>00842                                <span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1VarMatrix.html">IntensityMatrix</a> &amp;intensities,
<a name="l00843"></a>00843                                <span class="keywordtype">size_t</span> k)
<a name="l00844"></a>00844 {
<a name="l00845"></a>00845     assert(pxi_zj-&gt;numRows() == intensities.numRows());
<a name="l00846"></a>00846     assert(pxi_zj-&gt;numCols() == k);
<a name="l00847"></a>00847     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; k; ++j) {
<a name="l00848"></a>00848         <a class="code" href="classbirdseed_1_1dev_1_1FixedMatrix.html">Matrix2x2</a> varmat;
<a name="l00849"></a>00849         varmat[0][0] = clusters.vars[j][0];
<a name="l00850"></a>00850         varmat[0][1] = clusters.covar * sqrt(clusters.vars[j][0] * clusters.vars[j][1]);
<a name="l00851"></a>00851         varmat[1][0] = varmat[0][1];
<a name="l00852"></a>00852         varmat[1][1] = clusters.vars[j][1];
<a name="l00853"></a>00853         <span class="keywordtype">double</span> A = clusters.weights[j] * (1/pow(determinant(varmat), .5)) / (2*pi);
<a name="l00854"></a>00854         <a class="code" href="classbirdseed_1_1dev_1_1FixedMatrix.html">Matrix2x2</a> B = invert(varmat);
<a name="l00855"></a>00855         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; intensities.numRows(); ++i) {
<a name="l00856"></a>00856             <a class="code" href="classbirdseed_1_1dev_1_1FixedVector.html">FixedVector&lt;double, NUM_ALLELES&gt;</a> meanDelta = intensities[i] - clusters.means[j];
<a name="l00857"></a>00857             (*pxi_zj)[i][j] = A * exp(-((meanDelta * B * meanDelta)/2));
<a name="l00858"></a>00858         }
<a name="l00859"></a>00859     }
<a name="l00860"></a>00860 }
<a name="l00861"></a>00861 
<a name="l00862"></a>00862 <span class="keyword">static</span> <span class="keywordtype">void</span> estimation(<a class="code" href="classbirdseed_1_1dev_1_1Clusters.html">Clusters</a> *clusters, <span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1VarMatrix.html">IntensityMatrix</a> &amp;intensities, <span class="keywordtype">size_t</span> k)
<a name="l00863"></a>00863 {
<a name="l00864"></a>00864     calculatePXI_ZJ(&amp;clusters-&gt;pxi_zj, *clusters, intensities, k);
<a name="l00865"></a>00865     <span class="keywordtype">double</span> theSum = 0.0;
<a name="l00866"></a>00866     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> row = 0; row &lt; clusters-&gt;pxi_zj.numRows(); ++row) {
<a name="l00867"></a>00867         theSum += log(sumRow(clusters-&gt;pxi_zj, row));
<a name="l00868"></a>00868         
<a name="l00869"></a>00869     }
<a name="l00870"></a>00870     clusters-&gt;log_likelihood = theSum;
<a name="l00871"></a>00871 }
<a name="l00872"></a>00872 
<a name="l00873"></a>00873 <span class="keyword">static</span> <span class="keywordtype">void</span> finishEMLoop(<a class="code" href="classbirdseed_1_1dev_1_1Clusters.html">Clusters</a> *clusters, <span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1Priors.html">Priors</a> &amp;priors, <span class="keywordtype">size_t</span> k, <span class="keywordtype">size_t</span> numSamples)
<a name="l00874"></a>00874 {
<a name="l00875"></a>00875     <span class="comment">// Just syntactic sugar</span>
<a name="l00876"></a>00876     <a class="code" href="classbirdseed_1_1dev_1_1VarMatrixWithReservedRows.html">VarMatrixWithReservedRows&lt;double, MAX_NUM_CLUSTERS, NUM_ALLELES&gt;</a> &amp;means = clusters-&gt;means;
<a name="l00877"></a>00877 
<a name="l00878"></a>00878     vector&lt;double&gt; meandists(k-1);
<a name="l00879"></a>00879     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; k-1; ++i) {
<a name="l00880"></a>00880         meandists[i] = sqrt(sumVector(powVector(means[i+1] - means[i], 2)));
<a name="l00881"></a>00881     }
<a name="l00882"></a>00882     <span class="keywordtype">double</span> avgmeandist = sumVector(meandists)/meandists.size();
<a name="l00883"></a>00883     <span class="keywordtype">double</span> worstmeandist = maxInVector(meandists)/avgmeandist;
<a name="l00884"></a>00884     <span class="keywordtype">double</span> tempmeandist = INFINITY;
<a name="l00885"></a>00885     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; k-1; ++i) {
<a name="l00886"></a>00886         <span class="keywordtype">double</span> temp = (means[i+1][0]/means[i][0] + means[i][1]/means[i+1][1])/2;
<a name="l00887"></a>00887         tempmeandist = min(temp, tempmeandist);
<a name="l00888"></a>00888     }
<a name="l00889"></a>00889 
<a name="l00890"></a>00890         <span class="comment">// simplified version of the logic for testing the second cluster</span>
<a name="l00891"></a>00891         tempmeandist = (10.0/3) * (tempmeandist -
<a name="l00892"></a>00892                                    (priors.isDiploid()?
<a name="l00893"></a>00893                                     mean_dist2:
<a name="l00894"></a>00894                                     1.0));
<a name="l00895"></a>00895 
<a name="l00896"></a>00896     <span class="keywordtype">double</span> tempmeandist2 = INFINITY;
<a name="l00897"></a>00897     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; k-1; ++i) {
<a name="l00898"></a>00898         tempmeandist2 = min(tempmeandist2, means[i+1][0]/means[i][0]);
<a name="l00899"></a>00899         tempmeandist2 = min(tempmeandist2, means[i][1]/means[i+1][1]);
<a name="l00900"></a>00900     }
<a name="l00901"></a>00901 
<a name="l00902"></a>00902     <span class="keywordflow">if</span> ((k == 2) &amp;&amp; priors.isDiploid()) {
<a name="l00903"></a>00903         fillInMissingGaussians(clusters, priors, numSamples);
<a name="l00904"></a>00904     }
<a name="l00905"></a>00905 
<a name="l00906"></a>00906     <span class="keywordtype">double</span> bestpriorfit = 0.0;
<a name="l00907"></a>00907     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; priors.getNumPriors() - 1; ++i) {
<a name="l00908"></a>00908         <span class="keywordtype">double</span> delta_means0 = clusters-&gt;means[i][0]-clusters-&gt;means[i+1][0];
<a name="l00909"></a>00909         <span class="keywordtype">double</span> delta_means1 = clusters-&gt;means[i][1]-clusters-&gt;means[i+1][1];
<a name="l00910"></a>00910         <span class="keywordtype">double</span> mymeandist = sqrt((delta_means0 * delta_means0) + (delta_means1 * delta_means1));
<a name="l00911"></a>00911         delta_means0 = priors.getPrior(i).m_mean[0] - priors.getPrior(i+1).m_mean[0];
<a name="l00912"></a>00912         delta_means1 = priors.getPrior(i).m_mean[1] - priors.getPrior(i+1).m_mean[1];
<a name="l00913"></a>00913         <span class="keywordtype">double</span> priormeandist = sqrt((delta_means0 * delta_means0) + (delta_means1 * delta_means1));
<a name="l00914"></a>00914         bestpriorfit += abs(mymeandist-priormeandist)/(mymeandist+priormeandist);
<a name="l00915"></a>00915     }
<a name="l00916"></a>00916     
<a name="l00917"></a>00917         <span class="keywordflow">if</span> (verbosity&gt;2)
<a name="l00918"></a>00918         {
<a name="l00919"></a>00919                 cout &lt;&lt; <span class="stringliteral">&quot;finishEMlogL:\t&quot;</span>;
<a name="l00920"></a>00920                 cout &lt;&lt; clusters-&gt;log_likelihood &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00921"></a>00921                 cout &lt;&lt; log(static_cast&lt;double&gt;(numSamples))*max(0.0,low_covar_threshold-clusters-&gt;covar) &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00922"></a>00922                 cout &lt;&lt; log(static_cast&lt;double&gt;(numSamples))*max(0.0,worstmeandist-expected_wingspan_ratio) &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00923"></a>00923                 cout &lt;&lt; min(1.0,bestpriorfit) &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00924"></a>00924                 cout &lt;&lt; 0.5*(2*k+2+k)*log(static_cast&lt;double&gt;(numSamples)) &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00925"></a>00925                 cout &lt;&lt; endl;
<a name="l00926"></a>00926         }
<a name="l00927"></a>00927     <span class="comment">// log_likelihood is already sum(log(sum(pxi_zj,2))) ... %ll of data | gaussians</span>
<a name="l00928"></a>00928     clusters-&gt;log_likelihood = clusters-&gt;log_likelihood 
<a name="l00929"></a>00929         - low_covar_penalty*log(static_cast&lt;double&gt;(numSamples))*(max(0.0,low_covar_threshold-clusters-&gt;covar))  <span class="comment">// ll of covariance</span>
<a name="l00930"></a>00930         - unbalanced_wingspan_penalty*k*log(static_cast&lt;double&gt;(numSamples))*(max(0.0,worstmeandist-expected_wingspan_ratio))  <span class="comment">//ll of mean distribution</span>
<a name="l00931"></a>00931         - wing_length_delta_penalty*min(1.0, bestpriorfit)  <span class="comment">// ll of prior</span>
<a name="l00932"></a>00932         - bic_weight*0.5*(2*k+2+k)*log(static_cast&lt;double&gt;(numSamples)); <span class="comment">// ll of model (BIC criterion)</span>
<a name="l00933"></a>00933     <span class="keywordflow">if</span> (tempmeandist &lt; 0) { <span class="comment">//make sure the distance between means is enough</span>
<a name="l00934"></a>00934         clusters-&gt;log_likelihood = clusters-&gt;log_likelihood+k*tempmeandist*lambda3*k*log(static_cast&lt;double&gt;(numSamples));
<a name="l00935"></a>00935         <span class="keywordflow">if</span> (verbosity&gt;3)
<a name="l00936"></a>00936         {
<a name="l00937"></a>00937                 cout &lt;&lt; <span class="stringliteral">&quot;tempmeandist&lt;0:\t&quot;</span>;
<a name="l00938"></a>00938                 cout &lt;&lt; k*tempmeandist*k*log(static_cast&lt;double&gt;(numSamples)) &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00939"></a>00939                 cout &lt;&lt; endl;
<a name="l00940"></a>00940         }
<a name="l00941"></a>00941     }
<a name="l00942"></a>00942     <span class="keywordflow">if</span> (tempmeandist2&lt;cluster_distance_ratio_cutoff) { <span class="comment">// Make sure the order is correct (by a margin), or throw away:</span>
<a name="l00943"></a>00943         clusters-&gt;log_likelihood = -INFINITY;
<a name="l00944"></a>00944         <span class="keywordflow">if</span> (verbosity&gt;3)
<a name="l00945"></a>00945         {       
<a name="l00946"></a>00946                 cout &lt;&lt; <span class="stringliteral">&quot;tempmeandist2&lt;cluster_distance_ratio_cutoff:\t-INFINITY&quot;</span> &lt;&lt; endl;
<a name="l00947"></a>00947         }
<a name="l00948"></a>00948     }
<a name="l00949"></a>00949     <span class="keywordflow">if</span> ((k==3) &amp;&amp; (minInVector(clusters-&gt;weights)&lt;small_cluster_weight_threshold)) {
<a name="l00950"></a>00950         clusters-&gt;log_likelihood = clusters-&gt;log_likelihood 
<a name="l00951"></a>00951             - small_cluster_penalty*k*sqrt((small_cluster_weight_threshold-minInVector(clusters-&gt;weights)))*log(static_cast&lt;double&gt;(numSamples));
<a name="l00952"></a>00952         <span class="keywordflow">if</span> (verbosity&gt;3)
<a name="l00953"></a>00953         {
<a name="l00954"></a>00954                 cout &lt;&lt; <span class="stringliteral">&quot;Small_cluster_weight_threshold\t&quot;</span>;
<a name="l00955"></a>00955                 cout &lt;&lt; k*sqrt((small_cluster_weight_threshold-minInVector(clusters-&gt;weights)))*log(static_cast&lt;double&gt;(numSamples)) &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00956"></a>00956                 cout &lt;&lt; endl;
<a name="l00957"></a>00957         }
<a name="l00958"></a>00958     }
<a name="l00959"></a>00959 }
<a name="l00960"></a>00960 
<a name="l00961"></a>00961 <span class="comment">// false return means stop E-M loop.</span>
<a name="l00962"></a>00962 <span class="keyword">static</span> <span class="keywordtype">bool</span> maximization(<a class="code" href="classbirdseed_1_1dev_1_1Clusters.html">Clusters</a> *clusters,
<a name="l00963"></a>00963                          <span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1VarMatrix.html">IntensityMatrix</a> &amp;intensities,
<a name="l00964"></a>00964                          <span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1Priors.html">Priors</a> &amp;priors,
<a name="l00965"></a>00965                          <span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1FixedVector.html">FixedVector&lt;double, NUM_ALLELES&gt;</a> &amp;stdInterceptPrior,
<a name="l00966"></a>00966                          <span class="keywordtype">size_t</span> numSamples,
<a name="l00967"></a>00967                          <span class="keywordtype">size_t</span> k,
<a name="l00968"></a>00968                          <span class="keywordtype">size_t</span> iter)
<a name="l00969"></a>00969 {
<a name="l00970"></a>00970     <span class="comment">// Syntactic sugar</span>
<a name="l00971"></a>00971     <a class="code" href="classbirdseed_1_1dev_1_1VarMatrixWithReservedRows.html">VarMatrixWithReservedRows&lt;double, MAX_NUM_CLUSTERS, NUM_ALLELES&gt;</a> &amp;means = clusters-&gt;means;
<a name="l00972"></a>00972     
<a name="l00973"></a>00973     <a class="code" href="classbirdseed_1_1dev_1_1VarVectorWithReservedLength.html">VarVectorWithReservedLength&lt;double, MAX_NUM_CLUSTERS&gt;</a> nj(clusters-&gt;pxi_zj.numCols());
<a name="l00974"></a>00974     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> col = 0; col &lt; clusters-&gt;pxi_zj.numCols(); ++col) {
<a name="l00975"></a>00975         nj[col] = sumColumn(clusters-&gt;pxi_zj, col);
<a name="l00976"></a>00976         clusters-&gt;weights[col] = nj[col] / numSamples;
<a name="l00977"></a>00977     }
<a name="l00978"></a>00978     <span class="keywordtype">double</span> minNJ = minInVector(nj);
<a name="l00979"></a>00979     <span class="keywordflow">if</span> ((minNJ &lt; epsilon &amp;&amp; iter &gt; 10) || (minNJ &lt; eps &amp;&amp; iter &gt; 1)) {
<a name="l00980"></a>00980         clusters-&gt;log_likelihood = -INFINITY;
<a name="l00981"></a>00981         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00982"></a>00982     }
<a name="l00983"></a>00983     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; nj.size(); ++i) {
<a name="l00984"></a>00984         <span class="comment">// Floor to be at least smallest non-zero double.</span>
<a name="l00985"></a>00985         nj[i] = max(nj[i], numeric_limits&lt;double&gt;::epsilon());
<a name="l00986"></a>00986     }
<a name="l00987"></a>00987 
<a name="l00988"></a>00988     <a class="code" href="classbirdseed_1_1dev_1_1VarVector.html">VarVector&lt;double&gt;</a> covs(k);
<a name="l00989"></a>00989     
<a name="l00990"></a>00990         <span class="keywordtype">double</span> aweight = anchor_weight;
<a name="l00991"></a>00991         <span class="keywordflow">if</span>(k==2){
<a name="l00992"></a>00992           aweight = 0;
<a name="l00993"></a>00993         }
<a name="l00994"></a>00994 
<a name="l00995"></a>00995     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; k; ++j) {
<a name="l00996"></a>00996         <span class="comment">//Now With Anchoring:</span>
<a name="l00997"></a>00997             <span class="keywordtype">double</span> aweightj = min(nj[j]*max_anchor_percentage, aweight);
<a name="l00998"></a>00998 
<a name="l00999"></a>00999         <span class="comment">//means(j,:) = (min(nj(j)/3,anchorstrength)*priors(j,1:2)+sum(repmat(pxi_zj(:,j),1,2).*dataVector)) / (min(nj(j)/3,anchorstrength)+nj(j));</span>
<a name="l01000"></a>01000         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> col = 0; col &lt; NUM_ALLELES; ++col) {
<a name="l01001"></a>01001             <span class="keywordtype">double</span> meanSum = 0;
<a name="l01002"></a>01002             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> row = 0; row &lt; intensities.numRows(); ++row) {
<a name="l01003"></a>01003                 meanSum += clusters-&gt;pxi_zj[row][j] * intensities[row][col];
<a name="l01004"></a>01004             }
<a name="l01005"></a>01005                         meanSum += aweightj * priors.getPrior(j).m_mean[col];
<a name="l01006"></a>01006             means[j][col] = meanSum / (aweightj + nj[j]);
<a name="l01007"></a>01007         }
<a name="l01008"></a>01008 
<a name="l01009"></a>01009         <span class="comment">// vars(j,:) = 1/nj(j).*sum(repmat(pxi_zj(:,j),1,2) .* ((dataVector-repmat(means(j,:),n,1)).^2));</span>
<a name="l01010"></a>01010         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> col = 0; col &lt; NUM_ALLELES; ++col) {
<a name="l01011"></a>01011             <span class="keywordtype">double</span> varSum = 0;
<a name="l01012"></a>01012             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> row = 0; row &lt; intensities.numRows(); ++row) {
<a name="l01013"></a>01013                 varSum += clusters-&gt;pxi_zj[row][j] * ((intensities[row][col] - means[j][col]) * (intensities[row][col] - means[j][col]));
<a name="l01014"></a>01014             }
<a name="l01015"></a>01015             <span class="keywordtype">double</span> priormean = priors.getPrior(j).m_mean[col];
<a name="l01016"></a>01016                         varSum += aweightj * ((priormean - means[j][col]) * (priormean - means[j][col]));
<a name="l01017"></a>01017             clusters-&gt;vars[j][col] = varSum/(aweightj + nj[j]);
<a name="l01018"></a>01018         }
<a name="l01019"></a>01019 
<a name="l01020"></a>01020         <span class="comment">// covs(j) = 1/nj(j).* (pxi_zj(:,j) .* (dataVector(:,1)-repmat(means(j,1),n,1)))&#39;*(dataVector(:,2)-repmat(means(j,2),n,1));</span>
<a name="l01021"></a>01021         <span class="keywordtype">double</span> covSum = 0;
<a name="l01022"></a>01022         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> row = 0; row &lt; intensities.numRows(); ++row) {
<a name="l01023"></a>01023             covSum += clusters-&gt;pxi_zj[row][j] *
<a name="l01024"></a>01024                 (intensities[row][0] - means[j][0]) *
<a name="l01025"></a>01025                 (intensities[row][1] - means[j][1]);
<a name="l01026"></a>01026         }
<a name="l01027"></a>01027                 covSum += aweightj *
<a name="l01028"></a>01028                     (priors.getPrior(j).m_mean[0] - means[j][0]) *
<a name="l01029"></a>01029                     (priors.getPrior(j).m_mean[1] - means[j][1]);
<a name="l01030"></a>01030         covs[j] = covSum / (aweight + nj[j]);
<a name="l01031"></a>01031     }
<a name="l01032"></a>01032     <span class="comment">// covar = min(0.95,max(min_covar,sum(nj&#39;.*covs&#39;./(eps+sqrt(vars(:,1).*vars(:,2))))/sum(nj)));</span>
<a name="l01033"></a>01033     clusters-&gt;covar = min(max_covar2,max(min_covar,
<a name="l01034"></a>01034                                        sumVector(nj.multiplyElementwise(covs).divideElementwise
<a name="l01035"></a>01035                                                  (sqrtVector(clusters-&gt;vars.columnSlice(0).multiplyElementwise(clusters-&gt;vars.columnSlice(1))) + eps))/
<a name="l01036"></a>01036                                        sumVector(nj)));
<a name="l01037"></a>01037 
<a name="l01038"></a>01038     <span class="keywordflow">if</span> ((iter&lt;=covar_floor_decay) &amp;&amp; (k==2 || k==3)) {
<a name="l01039"></a>01039         clusters-&gt;covar = max(max_covar1-(iter-1.0)/covar_floor_decay, clusters-&gt;covar);
<a name="l01040"></a>01040         clusters-&gt;log_likelihood = -INFINITY;
<a name="l01041"></a>01041     }
<a name="l01042"></a>01042 
<a name="l01043"></a>01043     <span class="comment">// make sure the means aren&#39;t too close</span>
<a name="l01044"></a>01044     <span class="comment">// if(max((sqrt(sum((means(2:k,:)-means(1:k-1,:)).^2,2))&#39;./sqrt(sum(means(2:k,:).^2))))&lt;merged_cluster_threshold)</span>
<a name="l01045"></a>01045     <span class="keywordtype">double</span> maxDistance = -INFINITY;
<a name="l01046"></a>01046     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 1; i &lt; k; ++i) {
<a name="l01047"></a>01047         <span class="keywordtype">double</span> distance = sqrt(((means[i][0] - means[i-1][0]) * (means[i][0] - means[i-1][0])) + ((means[i][1] - means[i-1][1]) * (means[i][1] - means[i-1][1]))) /
<a name="l01048"></a>01048             sqrt((means[i][0] * means[i][0]) + (means[i][1] * means[i][1]));
<a name="l01049"></a>01049         maxDistance = max(maxDistance, distance);
<a name="l01050"></a>01050     }
<a name="l01051"></a>01051     <span class="keywordflow">if</span> (maxDistance &lt; merged_cluster_threshold) {
<a name="l01052"></a>01052         clusters-&gt;log_likelihood = -INFINITY;
<a name="l01053"></a>01053         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01054"></a>01054     }
<a name="l01055"></a>01055 
<a name="l01056"></a>01056     <span class="comment">// regularize the variances</span>
<a name="l01057"></a>01057     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> d = 0; d &lt; 2; ++d) {
<a name="l01058"></a>01058         <span class="comment">// vars(:,d) = nj&#39;./(nj&#39;+np).*vars(:,d) + ...</span>
<a name="l01059"></a>01059         <span class="comment">//        np./(nj&#39;+np).*((repmat(stdInterceptPrior(d),k,1)+std_slope*means(:,d)).^2); %regularization term 1</span>
<a name="l01060"></a>01060         <a class="code" href="classbirdseed_1_1dev_1_1VarVectorWithReservedLength.html">VarVectorWithReservedLength&lt;double, MAX_NUM_CLUSTERS&gt;</a> temp(nj.size());
<a name="l01061"></a>01061         temp = nj.divideElementwise(nj).multiplyElementwise(clusters-&gt;vars.columnSlice(d)); <span class="comment">// regularization term 1</span>
<a name="l01062"></a>01062         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; temp.size(); ++i) {
<a name="l01063"></a>01063             clusters-&gt;vars[i][d] = temp[i];
<a name="l01064"></a>01064         }
<a name="l01065"></a>01065     }
<a name="l01066"></a>01066 
<a name="l01067"></a>01067     <span class="comment">// how much variances are regularized to look like each other</span>
<a name="l01068"></a>01068     <span class="keywordtype">double</span> cluster_variance_regularization = cluster_variance_regularization_factor * intensities.numRows() * ((double(k-1)/k) * (<span class="keywordtype">double</span>(k-1)/k));
<a name="l01069"></a>01069 
<a name="l01070"></a>01070     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> d = 0; d &lt; 2; ++d) {
<a name="l01071"></a>01071         <span class="comment">// expectedvars = (mean(sqrt(vars(:,d))-std_slope*means(:,d)) +std_slope*means(:,d)).^2;</span>
<a name="l01072"></a>01072         <a class="code" href="classbirdseed_1_1dev_1_1VarVectorWithReservedLength.html">VarVectorWithReservedLength&lt;double, MAX_NUM_CLUSTERS&gt;</a> expectedvars(clusters-&gt;vars.numRows());
<a name="l01073"></a>01073 
<a name="l01074"></a>01074         expectedvars = powVector(clusters-&gt;means.columnSlice(d)*std_slope +
<a name="l01075"></a>01075                                  max(30.0,meanVector(sqrtVector(clusters-&gt;vars.columnSlice(d)) -
<a name="l01076"></a>01076                                                      clusters-&gt;means.columnSlice(d)*std_slope)), 2);
<a name="l01077"></a>01077 
<a name="l01078"></a>01078         <span class="comment">// vars(:,d) = nj&#39;./(nj&#39;+np+cluster_variance_regularization).*vars(:,d) + ...</span>
<a name="l01079"></a>01079         <span class="comment">//    cluster_variance_regularization./(nj&#39;+np+cluster_variance_regularization).*expectedvars; %regularization term 2</span>
<a name="l01080"></a>01080         <a class="code" href="classbirdseed_1_1dev_1_1VarVectorWithReservedLength.html">VarVectorWithReservedLength&lt;double, MAX_NUM_CLUSTERS&gt;</a> temp(clusters-&gt;vars.numRows());
<a name="l01081"></a>01081         <a class="code" href="classbirdseed_1_1dev_1_1VarVectorWithReservedLength.html">VarVectorWithReservedLength&lt;double, MAX_NUM_CLUSTERS&gt;</a> temp2(nj.size());
<a name="l01082"></a>01082         temp2 = nj + cluster_variance_regularization;
<a name="l01083"></a>01083         temp = nj.divideElementwise(temp2).multiplyElementwise(clusters-&gt;vars.columnSlice(d)) +
<a name="l01084"></a>01084             temp2.divisor(cluster_variance_regularization).multiplyElementwise(expectedvars);
<a name="l01085"></a>01085         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; temp.size(); ++i) {
<a name="l01086"></a>01086             clusters-&gt;vars[i][d] = temp[i];
<a name="l01087"></a>01087         }
<a name="l01088"></a>01088     }
<a name="l01089"></a>01089     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01090"></a>01090 }
<a name="l01091"></a>01091 
<a name="l01092"></a>01092 
<a name="l01093"></a>01093 <a class="code" href="classbirdseed_1_1dev_1_1Clusters.html">Clusters</a> birdseed::dev::FitSNPGaussianPriors3(<span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1VarMatrix.html">IntensityMatrix</a> &amp;intensities, <span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1Priors.html">Priors</a> &amp;priors)
<a name="l01094"></a>01094 {
<a name="l01095"></a>01095     <span class="keywordtype">size_t</span> numSamples = intensities.numRows();
<a name="l01096"></a>01096     
<a name="l01097"></a>01097     <a class="code" href="classbirdseed_1_1dev_1_1FixedVector.html">FixedVector&lt;double, NUM_ALLELES&gt;</a> stdInterceptPrior;
<a name="l01098"></a>01098     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; NUM_ALLELES; ++i) {
<a name="l01099"></a>01099         stdInterceptPrior[i] = computeStdInterceptPrior(priors, i);
<a name="l01100"></a>01100     }
<a name="l01101"></a>01101 
<a name="l01102"></a>01102     <span class="keyword">const</span> <span class="keywordtype">size_t</span> *numGaussians = (priors.isDiploid()? diploidNumGaussians: haploidNumGaussians);
<a name="l01103"></a>01103     <span class="keyword">const</span> <span class="keywordtype">size_t</span> lenNumGaussians = (priors.isDiploid()? lenDiploidNumGaussians: lenHaploidNumGaussians);
<a name="l01104"></a>01104     
<a name="l01105"></a>01105     <span class="comment">// It is required that we start with the 1 gaussian case</span>
<a name="l01106"></a>01106     assert(lenNumGaussians &gt; 0);
<a name="l01107"></a>01107     assert(numGaussians[0] == 1);
<a name="l01108"></a>01108     <a class="code" href="classbirdseed_1_1dev_1_1Clusters.html">Clusters</a> bestResult(1,1, 0);
<a name="l01109"></a>01109     <span class="keywordtype">size_t</span> bestpriormatch = monomorphicCluster(&amp;bestResult, intensities, priors, stdInterceptPrior);
<a name="l01110"></a>01110 
<a name="l01111"></a>01111     <span class="keywordflow">if</span> (verbosity &gt;= 2) {
<a name="l01112"></a>01112         cout &lt;&lt; <span class="stringliteral">&quot;oneGaussian result: &quot;</span> &lt;&lt; bestResult.tostring() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l01113"></a>01113     }
<a name="l01114"></a>01114     
<a name="l01115"></a>01115     <span class="comment">// Use k=1 case to estimate the variances for k=2 case</span>
<a name="l01116"></a>01116     <a class="code" href="classbirdseed_1_1dev_1_1VarMatrixWithReservedRows.html">VarMatrixWithReservedRows&lt;double, MAX_NUM_CLUSTERS, NUM_ALLELES&gt;</a> oldavgvars(bestResult.vars);
<a name="l01117"></a>01117     
<a name="l01118"></a>01118     
<a name="l01119"></a>01119     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> count = 1; count &lt; lenNumGaussians; ++count) {
<a name="l01120"></a>01120         <span class="keywordtype">size_t</span> k = numGaussians[count];
<a name="l01121"></a>01121         assert(k &gt; 1);
<a name="l01122"></a>01122         
<a name="l01123"></a>01123         <a class="code" href="classbirdseed_1_1dev_1_1Clusters.html">Clusters</a> clusters(intensities.numRows(), k, count);
<a name="l01124"></a>01124         initialize(&amp;clusters, k, count, intensities, priors, stdInterceptPrior, oldavgvars, bestpriormatch);
<a name="l01125"></a>01125 
<a name="l01126"></a>01126         <span class="comment">// EM loop:</span>
<a name="l01127"></a>01127         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> iter = 1; ; ++iter) {
<a name="l01128"></a>01128             <span class="keywordtype">double</span> old_log_likelihood = clusters.log_likelihood;
<a name="l01129"></a>01129             estimation(&amp;clusters, intensities, k);
<a name="l01130"></a>01130 
<a name="l01131"></a>01131             <span class="keywordflow">if</span> ((clusters.log_likelihood - old_log_likelihood &lt; epsilon) || (iter&gt;max_iter)) {
<a name="l01132"></a>01132                 <span class="keywordflow">if</span> (verbosity &gt;= 3) {
<a name="l01133"></a>01133                     cout &lt;&lt; <span class="stringliteral">&quot;Before finishEMLoop &quot;</span> &lt;&lt; <span class="stringliteral">&quot;count: &quot;</span> &lt;&lt; count &lt;&lt; <span class="stringliteral">&quot;; iter: &quot;</span> &lt;&lt; iter &lt;&lt; <span class="stringliteral">&quot;; &quot;</span> &lt;&lt; clusters.tostring() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l01134"></a>01134                 }
<a name="l01135"></a>01135                 finishEMLoop(&amp;clusters, priors, k, numSamples);
<a name="l01136"></a>01136                 <span class="keywordflow">if</span> (verbosity &gt;= 3) {
<a name="l01137"></a>01137                     cout &lt;&lt; <span class="stringliteral">&quot;After finishEMLoop &quot;</span> &lt;&lt; <span class="stringliteral">&quot;count: &quot;</span> &lt;&lt; count &lt;&lt; <span class="stringliteral">&quot;; iter: &quot;</span> &lt;&lt; iter &lt;&lt; <span class="stringliteral">&quot;; &quot;</span> &lt;&lt; clusters.tostring() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l01138"></a>01138                 }
<a name="l01139"></a>01139                 <span class="keywordflow">break</span>;
<a name="l01140"></a>01140             }
<a name="l01141"></a>01141             <span class="comment">// Normalize each row of pxi_zj so that each value is divided by the sum of values in that row</span>
<a name="l01142"></a>01142             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> row = 0; row &lt; clusters.pxi_zj.numRows(); ++row) {
<a name="l01143"></a>01143                 <span class="keywordtype">double</span> rowSum = sumRow(clusters.pxi_zj, row);
<a name="l01144"></a>01144                 <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> col = 0; col &lt; clusters.pxi_zj.numCols(); ++col) {
<a name="l01145"></a>01145                     <span class="keywordflow">if</span> (rowSum &gt; 0) {
<a name="l01146"></a>01146                         clusters.pxi_zj[row][col] /= rowSum;
<a name="l01147"></a>01147                     } <span class="keywordflow">else</span> {
<a name="l01148"></a>01148                         clusters.pxi_zj[row][col] = 1.0 / k;
<a name="l01149"></a>01149                     }
<a name="l01150"></a>01150                 }
<a name="l01151"></a>01151             }
<a name="l01152"></a>01152             <span class="keywordflow">if</span> (verbosity &gt;= 3) {
<a name="l01153"></a>01153                 cout &lt;&lt; <span class="stringliteral">&quot;Before maximization &quot;</span> &lt;&lt; <span class="stringliteral">&quot;count: &quot;</span> &lt;&lt; count &lt;&lt; <span class="stringliteral">&quot;; iter: &quot;</span> &lt;&lt; iter &lt;&lt; <span class="stringliteral">&quot;; &quot;</span> &lt;&lt; clusters.tostring() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l01154"></a>01154             }
<a name="l01155"></a>01155             
<a name="l01156"></a>01156             <span class="keywordflow">if</span> (!maximization(&amp;clusters, intensities, priors, stdInterceptPrior, numSamples, k, iter)) {
<a name="l01157"></a>01157                 <span class="keywordflow">break</span>;
<a name="l01158"></a>01158             }
<a name="l01159"></a>01159             <span class="keywordflow">if</span> (verbosity &gt;= 3) {
<a name="l01160"></a>01160                 cout &lt;&lt; <span class="stringliteral">&quot;After maximization &quot;</span> &lt;&lt; <span class="stringliteral">&quot;count: &quot;</span> &lt;&lt; count &lt;&lt; <span class="stringliteral">&quot;; iter: &quot;</span> &lt;&lt; iter &lt;&lt; <span class="stringliteral">&quot;; &quot;</span> &lt;&lt; clusters.tostring() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l01161"></a>01161             }
<a name="l01162"></a>01162         }
<a name="l01163"></a>01163         <span class="keywordflow">if</span> (verbosity &gt;= 2) {
<a name="l01164"></a>01164             cout &lt;&lt; <span class="stringliteral">&quot;After iter loop count: &quot;</span> &lt;&lt; count &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; clusters.tostring() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l01165"></a>01165         }
<a name="l01166"></a>01166         <span class="keywordflow">if</span> (clusters.log_likelihood &gt; bestResult.log_likelihood) {
<a name="l01167"></a>01167             bestResult = clusters;
<a name="l01168"></a>01168         }
<a name="l01169"></a>01169     }
<a name="l01170"></a>01170     <span class="keywordflow">if</span> (verbosity &gt;= 2) {
<a name="l01171"></a>01171         cout &lt;&lt; <span class="stringliteral">&quot;final result: &quot;</span> &lt;&lt; bestResult.tostring() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l01172"></a>01172     }
<a name="l01173"></a>01173 
<a name="l01174"></a>01174     <span class="comment">// This is no longer necessary so delete it.</span>
<a name="l01175"></a>01175     bestResult.pxi_zj.resizeRows(0);
<a name="l01176"></a>01176 
<a name="l01177"></a>01177     <span class="keywordflow">return</span> bestResult;
<a name="l01178"></a>01178 }
<a name="l01179"></a>01179 
<a name="l01180"></a>01180 <span class="keywordtype">double</span> birdseed::dev::calculateSNPSpecificCorrectionFactor(<span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1VarMatrix.html">IntensityMatrix</a> &amp;intensities,
<a name="l01181"></a>01181                                                       <span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1Priors.html">Priors</a> &amp;priors)
<a name="l01182"></a>01182 {
<a name="l01183"></a>01183     <span class="comment">// This could be done in a for loop to avoid memory allocation</span>
<a name="l01184"></a>01184     <span class="keywordtype">double</span> numerator = meanVector(sqrtVector(powVector(intensities.columnSlice(0), 2) + powVector(intensities.columnSlice(1), 2)));
<a name="l01185"></a>01185     <span class="keywordtype">double</span> denominator = 0.0;
<a name="l01186"></a>01186         <span class="keywordtype">double</span> numobstot = 0.0;
<a name="l01187"></a>01187         <span class="keywordtype">double</span> pseudos = 0.1; <span class="comment">//Make sure &gt;0 so don&#39;t get divide by 0 error</span>
<a name="l01188"></a>01188     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; priors.getNumPriors(); ++i) {
<a name="l01189"></a>01189             <span class="comment">//old: denominator += sqrt(pow(priors.getPrior(i).m_mean[0], 2) + pow(priors.getPrior(i).m_mean[1], 2));</span>
<a name="l01190"></a>01190             <span class="comment">//Each prior should be weighted by the number of observations for that prior (and then divide by the total number of observations); made more important due to anchoring</span>
<a name="l01191"></a>01191         <span class="keywordtype">double</span> numobscur = priors.getPrior(i).m_numObservations + pseudos;
<a name="l01192"></a>01192             numobstot += numobscur;
<a name="l01193"></a>01193         <span class="keywordtype">double</span> mean0 = priors.getPrior(i).m_mean[0];
<a name="l01194"></a>01194         <span class="keywordtype">double</span> mean1 = priors.getPrior(i).m_mean[1];
<a name="l01195"></a>01195         denominator += sqrt((mean0 * mean0) + (mean1 * mean1)) * numobscur;
<a name="l01196"></a>01196     }
<a name="l01197"></a>01197     <span class="comment">//old: denominator /= priors.getNumPriors();</span>
<a name="l01198"></a>01198         denominator /= numobstot;
<a name="l01199"></a>01199     <span class="keywordflow">return</span> numerator / denominator;
<a name="l01200"></a>01200 }
<a name="l01201"></a>01201 
<a name="l01202"></a>01202 <span class="keywordtype">double</span> birdseed::dev::calculateConfidenceRelativeToCluster(<span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1FixedMatrix.html">Matrix2x2</a> &amp;B,
<a name="l01203"></a>01203                                                       <span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1FixedVector.html">IntensityMatrix::ROW</a> &amp;intensities,
<a name="l01204"></a>01204                                                       <span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1FixedVector.html">IntensityMatrix::ROW</a> &amp;clusterMean)
<a name="l01205"></a>01205 {
<a name="l01206"></a>01206     <span class="keyword">static</span> <span class="keywordtype">double</span> exp_stdInflectionPoint = -1.0;
<a name="l01207"></a>01207     <span class="keywordflow">if</span> (exp_stdInflectionPoint &lt; 0) {
<a name="l01208"></a>01208         exp_stdInflectionPoint = exp(std_inflection_point);
<a name="l01209"></a>01209     }
<a name="l01210"></a>01210     <a class="code" href="classbirdseed_1_1dev_1_1FixedVector.html">IntensityMatrix::ROW</a> <a class="code" href="snp_8label_8cpp.html#ad748ef26c031cf6086e3a490afd3a47f" title="difference in cumulative sums: i.e.">delta</a> = intensities - clusterMean;
<a name="l01211"></a>01211     <span class="keywordtype">double</span> stdDist = sqrt((delta * B * delta)/2);
<a name="l01212"></a>01212     <span class="keywordtype">double</span> confidenceRelativeToCluster = 1/(1+exp(std_inflection_point-stdDist)) -
<a name="l01213"></a>01213         1/(1+exp_stdInflectionPoint);
<a name="l01214"></a>01214     <span class="keywordflow">return</span> confidenceRelativeToCluster;
<a name="l01215"></a>01215 }
<a name="l01216"></a>01216 
<a name="l01217"></a>01217 <a class="code" href="classbirdseed_1_1dev_1_1FixedMatrix.html">Matrix2x2</a> birdseed::dev::makeBMatrix(<span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1FixedVector.html">Matrix2x2::ROW</a> &amp;clusterVars, <span class="keywordtype">double</span> covar)
<a name="l01218"></a>01218 {
<a name="l01219"></a>01219     <a class="code" href="classbirdseed_1_1dev_1_1FixedMatrix.html">Matrix2x2</a> varmat;
<a name="l01220"></a>01220     varmat[0][0] = clusterVars[0];
<a name="l01221"></a>01221     varmat[1][0] = varmat[0][1] = covar * sqrt(clusterVars[0]*clusterVars[1]);
<a name="l01222"></a>01222     varmat[1][1] = clusterVars[1];
<a name="l01223"></a>01223     <span class="keywordflow">return</span> invert(varmat);
<a name="l01224"></a>01224 }
<a name="l01225"></a>01225 
<a name="l01226"></a>01226 <span class="comment">/******************************************************************/</span>
<a name="l01227"></a>01227 <span class="comment">/**************************[END OF FitSNPGaussiansPriors3.cpp]*************************/</span>
<a name="l01228"></a>01228 <span class="comment">/******************************************************************/</span>
<a name="l01229"></a>01229 
<a name="l01230"></a>01230 <span class="comment">/* Emacs configuration</span>
<a name="l01231"></a>01231 <span class="comment"> * Local Variables:</span>
<a name="l01232"></a>01232 <span class="comment"> * mode: C++</span>
<a name="l01233"></a>01233 <span class="comment"> * tab-width:4</span>
<a name="l01234"></a>01234 <span class="comment"> * End:</span>
<a name="l01235"></a>01235 <span class="comment"> */</span>
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jul 15 2014 10:37:20 for Affymetrix Power Tools by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
